<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BuyBacking Admin (No Build)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .animate-in { animation: fadeIn .18s ease-out; }
    @keyframes fadeIn { from { opacity:0; transform: translateY(4px);} to {opacity:1; transform:none;} }
    .scrollbar-hide::-webkit-scrollbar { display: none; }
    .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
    .density-compact tr td { padding-top: .4rem !important; padding-bottom: .4rem !important; }
    .density-compact .order-meta { gap: .25rem !important; }
    /* Tighter default density (still readable) */
    .density-default tr td { padding-top: .65rem !important; padding-bottom: .65rem !important; }
    @media (max-width: 640px) {
      #ordersTableBody tr td { padding-left: .6rem !important; padding-right: .6rem !important; }
      #ordersTableBody .text-sm { font-size: .78rem; }
      #ordersTableBody .text-xs { font-size: .68rem; }
      #ordersTableBody button { padding: .35rem .55rem !important; }
    }
  </style>
  <script>
    // Optional override:
    // window.SHC_API_BASE_URL = "https://api.secondhandcell.com/server";
    // Optional: enable aging mode by serving this page as .../aging.html then set:
    // window.IS_AGING_PAGE = true;
  </script>
</head>
<body class="bg-slate-50 text-slate-900">
  <div id="root"></div>
  <div id="runtimeErrors" class="fixed bottom-4 right-4 z-[99999] w-[92vw] max-w-xl hidden"></div>
  <!-- Lucide icons (vanilla) -->
  <script src="https://unpkg.com/lucide@latest"></script>
  <script type="module">
    import { initializeApp, getApps, getApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
    import { getAuth, onAuthStateChanged, signOut, signInWithEmailAndPassword } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
    import { getFirestore, collection, onSnapshot, doc, setDoc, updateDoc, getDoc, getDocs } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";
    // ----------------------------
    // CONFIG
    // ----------------------------
    const firebaseConfig = {
      apiKey: "AIzaSyAmUGWbpbJIWLrBMJpZb8iMpFt-uc24J0k",
      authDomain: "buyback-a0f05.firebaseapp.com",
      databaseURL: "https://buyback-a0f05-default-rtdb.firebaseio.com",
      projectId: "buyback-a0f05",
      storageBucket: "buyback-a0f05.firebasestorage.app",
      messagingSenderId: "876430429098",
      appId: "1:876430429098:web:f6dd64b1960d90461979d3",
      measurementId: "G-6WWQN44JHT"
    };
    const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const API_BASE_URL = window.SHC_API_BASE_URL || "https://api.secondhandcell.com/server";
    // Spec flags
    const IS_AGING_PAGE = !!window.IS_AGING_PAGE;
    const MIN_AGING_MS = 1000 * 60 * 60 * 24 * 7; // 7 days (safe default if not provided)
    // ----------------------------
    // DOM HELPERS
    // ----------------------------
    const $root = document.getElementById("root");
    const $runtimeErrors = document.getElementById("runtimeErrors");
    function reportUiError(message, meta = "") {
      if (!$runtimeErrors) return;
      const line = document.createElement("div");
      line.className = "mb-2 rounded-lg border border-rose-200 bg-rose-50 text-rose-800 px-3 py-2 text-xs shadow";
      const ts = new Date().toLocaleTimeString();
      line.textContent = `[${ts}] ${String(message || "Unknown error")}${meta ? ` — ${meta}` : ""}`;
      $runtimeErrors.prepend(line);
      $runtimeErrors.classList.remove("hidden");
      while ($runtimeErrors.children.length > 6) $runtimeErrors.removeChild($runtimeErrors.lastChild);
    }

    const originalConsoleError = console.error.bind(console);
    console.error = (...args) => {
      originalConsoleError(...args);
      const msg = args.map(a => {
        if (a instanceof Error) return a.message;
        if (typeof a === "object") {
          try { return JSON.stringify(a); } catch { return String(a); }
        }
        return String(a);
      }).join(" ");
      reportUiError(msg);
    };

    window.addEventListener("error", (event) => {
      reportUiError(event.message || "Unhandled runtime error", `${event.filename || ""}:${event.lineno || ""}`);
    });
    window.addEventListener("unhandledrejection", (event) => {
      const reason = event.reason instanceof Error ? event.reason.message : String(event.reason || "Promise rejected");
      reportUiError(reason, "Unhandled Promise rejection");
    });
    function esc(s) {
      return String(s ?? "").replace(/[&<>"']/g, m => ({ "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#039;" }[m]));
    }
    function safeUpperTrim(s) { return String(s ?? "").trim().toUpperCase(); }
    function toDateAny(ts) {
      if (!ts) return null;
      const d = ts?.seconds ? new Date(ts.seconds * 1000) : new Date(ts);
      return Number.isNaN(d.getTime()) ? null : d;
    }
    function formatDate(ts) {
      const d = toDateAny(ts);
      if (!d) return "N/A";
      return new Intl.DateTimeFormat("en-US", {
        month: "short",
        day: "2-digit",
        year: "numeric",
      }).format(d);
    }
    function formatTimeOnly(ts) {
      const d = toDateAny(ts);
      if (!d) return "N/A";
      return new Intl.DateTimeFormat("en-US", { hour: "numeric", minute: "2-digit" }).format(d);
    }
    function getOrderAge(ts) {
      const d = toDateAny(ts);
      if (!d) return "0 days";
      const diffMs = Math.max(0, Date.now() - d.getTime());
      const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24));
      return `${diffDays} day${diffDays !== 1 ? "s" : ""} old`;
    }
    function formatStatusLabel(status) {
      return String(status).replace(/_/g, " ").replace(/\b\w/g, c => c.toUpperCase());
    }
    // ----------------------------
    // SPEC: status buckets + dropdown
    // ----------------------------
    const STATUS_DROPDOWN_OPTIONS = [
      "order_pending",
      "shipping_kit_requested",
      "kit_needs_printing",
      "needs_printing",
      "kit_on_the_way_to_customer",
      "kit_delivered",
      "kit_on_the_way_to_us",
      "delivered_to_us",
      "label_generated",
      "emailed",
      "phone_on_the_way",
      "received",
      "completed",
      "re-offered-pending",
      "re-offered-accepted",
      "re-offered-declined",
      "re-offered-auto-accepted",
      "return-label-generated",
      "cancelled"
    ];
    const KIT_PRINT_PENDING_STATUSES = new Set(["shipping_kit_requested", "kit_needs_printing", "needs_printing"]);
    const RECEIVED_VALUES = new Set(["received", "imei_checked", "delivered_to_us", "phone_on_the_way"]);
    const PAST_RECEIVED_VALUES = new Set(["received", "completed", "re-offered-accepted", "re-offered-declined", "re-offered-auto-accepted"]);
    function normalizeStatusKey(status) {
      return String(status || "").trim().toLowerCase();
    }
    function isReceivedStatusValue(status) {
      return RECEIVED_VALUES.has(normalizeStatusKey(status));
    }
    function isStatusPastReceived(status) {
      return PAST_RECEIVED_VALUES.has(normalizeStatusKey(status));
    }
    function isBalanceEmailStatus(order) {
      const s = normalizeStatusKey(order?.status);
      return s.includes("emailed_balance") || s.includes("emailed") && (order?.emailType === "balance");
    }
    function isLabelGenerationStage(order) {
      const s = normalizeStatusKey(order?.status);
      return s === "label_generated" || s === "needs_printing" || s === "kit_needs_printing";
    }
    function getStatusClass(status) {
      const s = normalizeStatusKey(status);
      if (!s || s === "unknown") return "bg-slate-100 text-slate-800 border-slate-200";
      if (s.includes("cancel")) return "bg-slate-100 text-slate-600 border-slate-200";
      if (s.includes("pending") || s.includes("needs_printing") || s.includes("kit_needs_printing")) return "bg-amber-100 text-amber-800 border-amber-200";
      if (s.includes("kit") || s.includes("label") || s.includes("transit") || s.includes("delivered_to_us") || s.includes("phone_on_the_way")) return "bg-blue-100 text-blue-800 border-blue-200";
      if (s.includes("emailed") || s.includes("received") || s.includes("imei_checked")) return "bg-indigo-100 text-indigo-800 border-indigo-200";
      if (s.includes("completed") || s.includes("paid")) return "bg-emerald-100 text-emerald-800 border-emerald-200";
      if (s.includes("re-offer") || s.includes("re_offer")) return "bg-purple-100 text-purple-800 border-purple-200";
      return "bg-slate-100 text-slate-800 border-slate-200";
    }
    function getStatusAccentBgClass(status) {
      const s = normalizeStatusKey(status);
      if (!s || s === "unknown") return "bg-slate-300";
      if (s.includes("cancel")) return "bg-slate-300";
      if (s.includes("pending") || s.includes("needs_printing") || s.includes("kit_needs_printing")) return "bg-amber-400";
      if (s.includes("kit") || s.includes("label") || s.includes("transit") || s.includes("delivered_to_us") || s.includes("phone_on_the_way")) return "bg-blue-500";
      if (s.includes("emailed") || s.includes("received") || s.includes("imei_checked")) return "bg-indigo-500";
      if (s.includes("completed") || s.includes("paid")) return "bg-emerald-500";
      if (s.includes("re-offer") || s.includes("re_offer")) return "bg-purple-500";
      return "bg-slate-300";
    }
    function statusBadgeHTML(status, extra = "") {
      return `
        <div class="inline-flex flex-col gap-1">
          <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border ${getStatusClass(status)}">
            ${esc(formatStatusLabel(status))}
          </span>
          ${extra ? `<div class="text-[11px] text-slate-500">${extra}</div>` : ""}
        </div>
      `;
    }
    // ----------------------------
    // SPEC: promo filter
    // ----------------------------
    const PROMO_FILTER = { ALL: "all", WITH: "with", NONE: "none" };
    function extractOrderPromoCode(order) {
      const raw =
        order?.promoCode ??
        order?.promo_code ??
        order?.promo ??
        order?.promo_code_used ??
        "";
      const code = safeUpperTrim(raw);
      return code || "";
    }
    function getPromoBonusAmount(order) {
      const v = order?.promoBonusAmount ?? order?.promo_bonus ?? 0;
      const n = Number(v);
      return Number.isFinite(n) ? n : 0;
    }
    function matchesPromoFilter(order, filterValue) {
      const code = extractOrderPromoCode(order);
      if (!filterValue || filterValue === PROMO_FILTER.ALL) return true;
      if (filterValue === PROMO_FILTER.WITH) return !!code;
      if (filterValue === PROMO_FILTER.NONE) return !code;
      if (String(filterValue).startsWith("code:")) {
        const target = safeUpperTrim(String(filterValue).slice(5));
        return code === target;
      }
      return true;
    }
    function refreshPromoFilterOptions() {
      const sel = document.getElementById("promoFilterSelect");
      if (!sel) return;
      const prev = state.currentPromoFilter || PROMO_FILTER.ALL;
      const unique = new Set();
      state.allOrders.forEach(o => {
        const code = extractOrderPromoCode(o);
        if (code) unique.add(code);
      });
      const codes = Array.from(unique).sort((a,b) => a.localeCompare(b));
      const options = [
        { value: PROMO_FILTER.ALL, label: "All" },
        { value: PROMO_FILTER.WITH, label: "Promo used" },
        { value: PROMO_FILTER.NONE, label: "No promo" },
        ...codes.map(c => ({ value: `code:${c}`, label: `Code: ${c}` }))
      ];
      sel.innerHTML = options.map(o => `<option value="${esc(o.value)}">${esc(o.label)}</option>`).join("");
      sel.value = options.some(o => o.value === prev) ? prev : PROMO_FILTER.ALL;
      state.currentPromoFilter = sel.value;
    }
    // ----------------------------
    // SPEC: device key + per-device entries
    // ----------------------------
    function buildOrderDeviceKey(orderId, deviceIndex = 0) {
      return `${orderId}::${deviceIndex}`;
    }
    function parseOrderDeviceKey(deviceKey) {
      const [orderId, deviceIndexStr] = String(deviceKey).split("::");
      const deviceIndex = Number.parseInt(deviceIndexStr || "0", 10);
      return { orderId, deviceIndex: Number.isFinite(deviceIndex) ? deviceIndex : 0 };
    }
    function normalizeQty(q) {
      const n = Number(q);
      if (!Number.isFinite(n)) return 1;
      return Math.max(1, Math.floor(n));
    }
    function getOrderDeviceEntries(order) {
      const items = Array.isArray(order?.items) ? order.items : [];
      if (!items.length) return [{ deviceIndex: 0, item: order, qtyIndex: 0 }];
      const out = [];
      let idx = 0;
      for (const it of items) {
        const qty = normalizeQty(it?.qty ?? it?.quantity ?? 1);
        for (let i = 0; i < qty; i++) {
          out.push({ deviceIndex: idx, item: it, qtyIndex: i });
          idx++;
        }
      }
      return out.length ? out : [{ deviceIndex: 0, item: order, qtyIndex: 0 }];
    }
    function getPerDeviceOffer(item, order) {
      const qty = normalizeQty(item?.qty ?? item?.quantity ?? 1);
      const direct = Number(item?.unitPrice ?? item?.price ?? item?.payout ?? item?.offerAmount ?? item?.estimatedQuote);
      if (Number.isFinite(direct)) return direct;
      const total = Number(item?.totalPayout ?? item?.estimatedQuote ?? order?.totalPayout ?? order?.estimatedQuote ?? order?.originalQuote);
      if (Number.isFinite(total)) return qty > 1 ? (total / qty) : total;
      return 0;
    }
    function isAcceptedReofferStatus(status) {
      const s = normalizeStatusKey(status);
      return s === 're-offered-accepted' || s === 're_offered_accepted' || s === 're-offered-auto-accepted' || s === 're_offered_auto_accepted' || s === 'requote_accepted';
    }
    function getAcceptedReofferPayout(order) {
      const candidates = [order?.reOffer?.newPrice, order?.reoffer?.newPrice, order?.finalPayoutAmount, order?.requoteAmount, order?.requote?.amount, order?.updatedQuote];
      for (const c of candidates) {
        const n = Number(c);
        if (Number.isFinite(n) && n > 0) return n;
      }
      return null;
    }
    function getOriginalPayout(order) {
      const candidates = [order?.originalQuote, order?.initialQuote, order?.quotedAmount, order?.totalPayout];
      for (const c of candidates) {
        const n = Number(c);
        if (Number.isFinite(n) && n > 0) return n;
      }
      return null;
    }
    function formatCarrierLabel(carrierRaw) {
      const c = String(carrierRaw || '').trim().toLowerCase();
      if (!c) return 'N/A';
      if (c === 'tmobile' || c === 't-mobile') return 'T-Mobile';
      if (c === 'att' || c === 'at&t' || c === 'at and t') return 'AT&T';
      if (c === 'verizon') return 'Verizon';
      if (c === 'unlocked') return 'Unlocked';
      return c.replace(/\b\w/g, (m) => m.toUpperCase());
    }
    function getOrderItemsSearchText(order) {
      // Used by search pipeline
      const entries = getOrderDeviceEntries(order);
      const bits = [];
      for (const e of entries) {
        const it = e.item || {};
        bits.push(it.device, it.model, it.storage, it.carrier, it.condition, it.color, it.imei, it.serial);
      }
      return safeUpperTrim(bits.filter(Boolean).join(" "));
    }
    // ----------------------------
    // SPEC: tracking hints + tracking # detection
    // ----------------------------
    function getAnyTrackingNumber(order) {
      return (
        order?.trackingNumber ||
        order?.inboundTrackingNumber ||
        order?.outboundTrackingNumber ||
        order?.labelTrackingNumber ||
        order?.uspsTrackingNumber ||
        order?.uspsLabelTrackingNumber ||
        order?.labelTrackingStatus?.trackingNumber ||
        order?.labelTrackingStatus?.tracking_number ||
        order?.kitTrackingStatus?.trackingNumber ||
        order?.kitTrackingStatus?.tracking_number ||
        ""
      );
    }
    function getShipEngineLabelEntries(order) {
      const labels = order?.shipEngineLabels;
      if (!labels) return [];
      if (Array.isArray(labels)) {
        return labels
          .map((value, index) => ({ key: String(value?.key || `label_${index + 1}`), value }))
          .filter((entry) => entry.value && typeof entry.value === "object");
      }
      if (typeof labels === "object") {
        return Object.entries(labels)
          .filter(([, value]) => value && typeof value === "object")
          .map(([key, value]) => ({ key, value }));
      }
      return [];
    }
    function shipEngineLabelTrackings(order) {
      const nums = [];
      for (const { value } of getShipEngineLabelEntries(order)) {
        if (value?.trackingNumber) nums.push(value.trackingNumber);
        if (value?.tracking_number) nums.push(value.tracking_number);
      }
      return nums.filter(Boolean);
    }
    function hasKitTrackingNumbers(order) {
      const nums = [
        order?.outboundTrackingNumber,
        order?.inboundTrackingNumber,
        order?.trackingNumber,
        order?.kitTrackingStatus?.trackingNumber,
        order?.kitTrackingStatus?.tracking_number,
        ...shipEngineLabelTrackings(order),
      ].filter(Boolean);
      return nums.length > 0;
    }
    function hasEmailTrackingNumbers(order) {
      const nums = [
        order?.labelTrackingNumber,
        order?.trackingNumber,
        order?.uspsTrackingNumber,
        order?.uspsLabelTrackingNumber,
        order?.labelTrackingStatus?.trackingNumber,
        order?.labelTrackingStatus?.tracking_number,
        ...shipEngineLabelTrackings(order),
      ].filter(Boolean);
      return nums.length > 0;
    }
    function matchesKitTrackingHints(order) {
      const s = normalizeStatusKey(order?.status);
      const pref = normalizeStatusKey(order?.shippingPreference);
      return pref.includes("kit") || s.includes("kit") || s.includes("printing") || s.includes("delivered");
    }
    function matchesEmailTrackingHints(order) {
      const s = normalizeStatusKey(order?.status);
      const pref = normalizeStatusKey(order?.shippingPreference);
      if (isBalanceEmailStatus(order)) return false;
      return pref.includes("email") || pref.includes("label") || s.includes("emailed") || s.includes("label") || s.includes("phone_on_the_way");
    }
    // ----------------------------
    // API HELPERS (authRequired always)
    // ----------------------------
    async function apiCall(endpoint, method = "GET", body = null) {
      const user = auth.currentUser;
      const token = user ? await user.getIdToken() : null;
      const headers = {
        ...(token ? { "Authorization": `Bearer ${token}` } : {}),
      };
      // send JSON only if body present
      const safeEndpoint = endpoint.startsWith("/") ? endpoint : `/${endpoint}`;
      const config = { method, headers };
      if (body !== null && body !== undefined) {
        config.headers["Content-Type"] = "application/json";
        config.body = JSON.stringify(body);
      }
      const res = await fetch(`${API_BASE_URL}${safeEndpoint}`, config);
      const data = await res.json().catch(() => ({}));
      if (!res.ok) throw new Error(data.message || data.error || "API Request Failed");
      return data;
    }
    const apiGet = (p) => apiCall(p, "GET");
    const apiPost = (p, b) => apiCall(p, "POST", b ?? {});
    const apiPut = (p, b) => apiCall(p, "PUT", b ?? {});
    const apiDelete = (p) => apiCall(p, "DELETE", null);
    function toast(msg, type="info") {
      const el = document.createElement("div");
      el.className = `fixed bottom-4 left-1/2 -translate-x-1/2 z-[1002] px-4 py-2 rounded-lg text-sm font-medium shadow-lg border ${
        type === "error" ? "bg-rose-50 text-rose-800 border-rose-200"
        : type === "success" ? "bg-emerald-50 text-emerald-800 border-emerald-200"
        : "bg-white text-slate-800 border-slate-200"
      }`;
      el.textContent = msg;
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 2800);
    }
    // ----------------------------
    // SPEC: GLOBAL STATE
    // ----------------------------
    const state = {
      user: null,
      authLoading: true,
      sidebarOpen: false,
      // orders master + filtered
      allOrders: [],
      currentFilteredOrders: [],
      currentActiveStatus: "all",
      currentSearchTerm: "",
      currentPromoFilter: PROMO_FILTER.ALL,
      // pagination
      ORDERS_PER_PAGE: 20,
      currentPage: 1,
      // bulk selection
      selectedOrderIds: new Set(),
      expandedOrderIds: new Set(),
      lastRenderedDeviceKeys: [],
      // density
      compactDensity: false,
      // UI tabs
      activeTab: "orders",
      // drawer / modal
      selectedOrderId: null,
      selectedOrderSnapshot: null,
      selectedDeviceKey: null,
      drawerTab: "overview",
      // QC modal (your existing)
      qcOpen: false,
      qcStep: 1,
      qcData: null,
      qcDeviceKey: null,
      reofferOpen: false,
      reofferData: null,
      qcModelCache: {},
      qcStorageCache: {},
      viewDelegationBound: false,
      // status dropdown (modal)
      statusDropdownOpen: false,
      // order text import (placeholder modal)
      orderTextImportOpen: false,
      modalScrollTop: { qc: 0, reoffer: 0, import: 0 },
      // bulk states
      isBulkLabelGenerationInProgress: false,
      lastRefreshAt: null,
    };
    function getSelectedOrder() {
      if (!state.selectedOrderId) return null;
      const liveOrder = state.allOrders.find(o => o.id === state.selectedOrderId) || null;
      if (liveOrder) {
        state.selectedOrderSnapshot = liveOrder;
        return liveOrder;
      }
      return state.selectedOrderSnapshot || null;
    }

    function getOrderPayoutTotal(order) {
      const explicit = Number(order?.totalPayout ?? order?.total_payout ?? order?.payoutTotal ?? order?.payout_total ?? NaN);
      if (Number.isFinite(explicit)) return explicit;
      const items = Array.isArray(order?.items) ? order.items : [];
      if (!items.length) {
        const single = Number(order?.price ?? order?.payout ?? 0);
        return Number.isFinite(single) ? single : 0;
      }
      let sum = 0;
      for (const it of items) {
        const qty = normalizeQty(it?.qty ?? it?.quantity ?? 1);
        const unit = Number.parseFloat(it?.price ?? it?.payout ?? 0);
        sum += (Number.isFinite(unit) ? unit : 0) * qty;
      }
      return sum;
    }

    function normalizeCarrierForPricing(value) {
      const v = String(value || '').toLowerCase().replace(/[^a-z0-9]/g, '');
      if (!v) return 'unlocked';
      if (v.includes('tmobile') || v === 'tmo') return 'tmobile';
      if (v.includes('att')) return 'att';
      if (v.includes('verizon')) return 'verizon';
      if (v.includes('unlock')) return 'unlocked';
      if (v.includes('other')) return 'other';
      return v;
    }


    const qcSortStorage = (values = []) => {
      const toGb = (val) => {
        const s = String(val || '').toLowerCase().trim();
        const num = Number.parseFloat(s);
        if (!Number.isFinite(num)) return 0;
        return s.includes('tb') ? num * 1024 : num;
      };
      return [...values].sort((a,b) => toGb(a)-toGb(b));
    };

    async function getModelsForBrand(brand) {
      const key = String(brand || '').toLowerCase();
      if (!key) return [];
      if (state.qcModelCache[key]) return state.qcModelCache[key];
      try {
        const snap = await getDocs(collection(db, 'devices', key, 'models'));
        const models = snap.docs.map(d => ({ id: d.id, ...(d.data() || {}) }));
        state.qcModelCache[key] = models;
        return models;
      } catch {
        return [];
      }
    }

    async function getStorageForModel(brand, modelId) {
      const b = String(brand || '').toLowerCase();
      const m = String(modelId || '');
      if (!b || !m) return [];
      const cacheKey = `${b}::${m}`;
      if (state.qcStorageCache[cacheKey]) return state.qcStorageCache[cacheKey];
      try {
        const snap = await getDoc(doc(db, 'devices', b, 'models', m));
        if (!snap.exists()) return [];
        const data = snap.data() || {};
        const storageKeys = Object.keys(data.prices || {});
        const sorted = qcSortStorage(storageKeys);
        state.qcStorageCache[cacheKey] = sorted;
        return sorted;
      } catch {
        return [];
      }
    }

    async function getQcOfferFromDb(order, qcData = null) {
      const focused = getFocusedDevice(order);
      const item = focused?.entry?.item || order || {};
      const brand = String(qcData?.actualBrand || item.brand || order.brand || '').toLowerCase();
      const modelId = qcData?.actualModelId || item.modelId || item.model || order.modelId || order.model;
      const storage = String((qcData?.storageMatch === 'no' ? qcData?.actualStorage : qcData?.storage) || item.storage || order.storage || '');
      const carrier = normalizeCarrierForPricing(qcData?.carrier || item.carrier || item.lock || order.carrier || order.lock || 'unlocked');
      const conditionRaw = String(qcData?.condition || item.condition || order.condition || 'good').toLowerCase();
      const condition = conditionRaw === 'damaged' ? 'broken' : conditionRaw;
      if (!brand || !modelId || !storage) return null;
      try {
        const snap = await getDoc(doc(db, 'devices', brand, 'models', modelId));
        if (!snap.exists()) return null;
        const data = snap.data() || {};
        const prices = data.prices || {};
        const storageMap = prices[storage] || prices[String(storage).toUpperCase()] || prices[String(storage).toLowerCase()];
        if (!storageMap) return null;
        const carrierMap = storageMap[carrier] || storageMap.unlocked || storageMap.other;
        if (!carrierMap) return null;
        const offer = Number(carrierMap[condition] || 0);
        return Number.isFinite(offer) ? offer : null;
      } catch {
        return null;
      }
    }

    function composeReofferReasoning(order, qcData = null, computedPrice = null) {
      const reasons = [];
      if (!qcData) return reasons;
      if (qcData.deviceMatch === 'no') reasons.push('Device received does not match the original model selection.');
      if (qcData.storageMatch === 'no') reasons.push('Storage/GB amount differs from what was quoted.');
      if (qcData.hasDamage === 'yes') reasons.push('Physical damage beyond normal wear was found in inspection.');
      if (qcData.hasCracks === 'yes') reasons.push('Cracked glass/back lowers the device value.');
      if (qcData.isFunctional === 'no') reasons.push('Device is not fully functional during testing.');
      if (qcData.isLocked === 'yes') reasons.push('Activation/carrier lock is still active.');
      if (qcData.hasFmi === 'yes') reasons.push('Find My iPhone (FMI) is still active.');
      if (qcData.hasBalance === 'yes') reasons.push('Outstanding carrier/financing balance is present.');
      if (Number.isFinite(computedPrice)) reasons.push('Updated offer uses current live pricing based on verified condition, carrier, and storage.');
      if (qcData.notes) reasons.push(`Inspector notes: ${qcData.notes}`);
      return reasons;
    }

    async function openReofferModal(order, qcData = null) {
      const fallbackPrice = getOrderPayoutTotal(order);
      const computedPrice = await getQcOfferFromDb(order, qcData);
      const finalPrice = Number.isFinite(computedPrice) ? computedPrice : fallbackPrice;
      const reasons = composeReofferReasoning(order, qcData, computedPrice);
      state.reofferData = {
        newPrice: Number(finalPrice || 0).toFixed(2),
        reasons: reasons.join('\n'),
        comments: qcData?.deviceMatch === 'no' ? `Device mismatch: ${qcData?.deviceName || 'updated in QC'}` : '',
        carrier: qcData?.carrier || order?.carrier || order?.lock || '',
        condition: qcData?.condition || order?.condition || 'good'
      };
      state.reofferOpen = true;
    }

    function getFocusedDevice(order) {
      const entries = getOrderDeviceEntries(order);
      const fallbackEntry = entries[0] || { deviceIndex: 0, item: order, qtyIndex: 0 };
      const key = state.selectedDeviceKey;
      if (!key) return { isFocused: false, deviceKey: null, entry: null, entries, label: `Devices (${entries.length})` };
      const parsed = parseOrderDeviceKey(key);
      if (parsed.orderId !== order?.id) return { isFocused: false, deviceKey: null, entry: null, entries, label: `Devices (${entries.length})` };
      const entry = entries.find(e => e.deviceIndex === parsed.deviceIndex) || fallbackEntry;
      const deviceKey = buildOrderDeviceKey(order.id, entry.deviceIndex);
      const label = `Device ${entry.deviceIndex + 1} of ${entries.length}`;
      return { isFocused: true, deviceKey, entry, entries, label };
    }
    function getLastUpdateTimestamp(order) {
      return (
        order?.updatedAt ||
        order?.updated_at ||
        order?.statusUpdatedAt ||
        order?.lastStatusUpdateAt ||
        order?.lastUpdatedAt ||
        order?.last_update_at ||
        null
      );
    }
    // ----------------------------
    // FIRESTORE LISTENER
    // ----------------------------
    let unsubscribeOrders = null;
    function startOrdersListener() {
      if (unsubscribeOrders) unsubscribeOrders();
      const ordersRef = collection(db, "orders");
      unsubscribeOrders = onSnapshot(ordersRef, (snapshot) => {
        const ordersData = snapshot.docs.map(d => {
          const data = d.data();
          const createdAtMillis = data.createdAt?.seconds ? data.createdAt.seconds * 1000 : (toDateAny(data.createdAt)?.getTime() || 0);
          return { id: d.id, ...data, createdAtMillis };
        });
        ordersData.sort((a, b) => (b.createdAtMillis || 0) - (a.createdAtMillis || 0));
        state.allOrders = ordersData;
        // keep promo filter options in sync
        // (call after render since select exists only on orders tab; but safe to call now too)
        // We'll call in bindAppEvents as well.
        // Keep drawer open until admin explicitly closes it.
        // If a selected order is temporarily missing from the live snapshot,
        // render falls back to the last selectedOrderSnapshot.
        // Re-run filter pipeline to keep pagination + selection consistent
        filterAndRenderOrders(state.currentActiveStatus, state.currentSearchTerm, { preservePage: true });
      }, (err) => {
        console.error("Firestore Error:", err);
        toast("Failed to load orders", "error");
        // still render shell
        render();
      });
    }
    // ----------------------------
    // SPEC: CANCELLED HANDLING + BASE ORDERS
    // ----------------------------
    function splitCancelled(orders) {
      const cancelled = [];
      const visible = [];
      for (const o of orders) {
        if (normalizeStatusKey(o?.status) === "cancelled") cancelled.push(o);
        else visible.push(o);
      }
      return { visible, cancelled };
    }
    function getBaseOrdersForStatus(status) {
      const s = normalizeStatusKey(status);
      const { visible, cancelled } = splitCancelled(state.allOrders);
      if (s === "cancelled") return cancelled;
      if (s === "all") return visible; // default excludes cancelled
      // other statuses also based on visible, unless explicitly cancelled
      return visible;
    }
    // ----------------------------
    // SPEC: SEARCH INPUT SYNC
    // ----------------------------
    function syncSearchInputs(v) {
      const a = document.getElementById("searchInput");
      const b = document.getElementById("mobileSearchInput");
      if (a && a.value !== v) a.value = v;
      if (b && b.value !== v) b.value = v;
    }
    function applySearchTerm(v) {
      state.currentSearchTerm = v || "";
      filterAndRenderOrders(state.currentActiveStatus, state.currentSearchTerm, { preservePage: false });
    }
    // ----------------------------
    // SPEC: AGING PAGE FILTER
    // ----------------------------
    function isAgingCandidate(order) {
      const s = normalizeStatusKey(order?.status);
      // block completed/cancelled/return label generated by default
      const blocked = new Set(["completed", "cancelled", "return-label-generated"]);
      if (blocked.has(s)) return false;
      const d = toDateAny(order?.createdAt);
      if (!d) return false;
      const age = Date.now() - d.getTime();
      return age >= MIN_AGING_MS;
    }
    // ----------------------------
    // SPEC: FILTER PIPELINE (source of truth)
    // ----------------------------
    function filterAndRenderOrders(status, searchTerm = state.currentSearchTerm, options = {}) {
      const s = normalizeStatusKey(status || "all");
      const term = String(searchTerm || "");
      const termLower = term.toLowerCase();
      state.currentActiveStatus = s;
      state.currentSearchTerm = term;
      syncSearchInputs(term);
      // base list
      let base = getBaseOrdersForStatus(s);
      // status rules (only when no search term and not "all")
      let out = base.slice();
      if (!term && s !== "all") {
        if (s === "kit_needs_printing") {
          out = out.filter(o => KIT_PRINT_PENDING_STATUSES.has(normalizeStatusKey(o?.status)));
        } else if (s === "label_generated") {
          out = out.filter(o => isLabelGenerationStage(o));
        } else if (s === "emailed") {
          out = out.filter(o => isBalanceEmailStatus(o) || normalizeStatusKey(o?.status) === "emailed");
        } else if (s === "received") {
          out = out.filter(o => isReceivedStatusValue(o?.status));
        } else {
          out = out.filter(o => normalizeStatusKey(o?.status) === s);
        }
      }
      // promo filter always applies
      out = out.filter(o => matchesPromoFilter(o, state.currentPromoFilter));
      // search term overrides (search within the already status/promo-filtered list to match your spec)
      if (term) {
        out = out.filter(order => {
          const id = String(order?.id || "");
          const fullName = String(order?.shippingInfo?.fullName || "");
          const tracking = String(getAnyTrackingNumber(order) || "");
          const deviceBits = (getOrderItemsSearchText(order) || "");
          const storage = String(order?.storage || "");
          const device = String(order?.device || "");
          const combined = `${id} ${fullName} ${device} ${storage} ${tracking} ${deviceBits}`.toLowerCase();
          return combined.includes(termLower);
        });
      }
      // aging page mode
      if (IS_AGING_PAGE) out = out.filter(isAgingCandidate);
      // sort newest first by createdAt
      out.sort((a, b) => {
        const ta = toDateAny(a?.createdAt)?.getTime() || 0;
        const tb = toDateAny(b?.createdAt)?.getTime() || 0;
        return tb - ta;
      });
      state.currentFilteredOrders = out;
      // pagination
      const totalPages = Math.max(1, Math.ceil(out.length / state.ORDERS_PER_PAGE));
      if (options?.preservePage) {
        state.currentPage = Math.min(state.currentPage, totalPages);
        state.currentPage = Math.max(1, state.currentPage);
      } else {
        state.currentPage = 1;
      }
      render();
    }
    // ----------------------------
    // SPEC: BULK SELECTION (order)
    // ----------------------------
    function setOrderSelected(orderId, checked) {
      if (checked) state.selectedOrderIds.add(orderId);
      else state.selectedOrderIds.delete(orderId);
    }
    function computeSelectAllState() {
      const pageKeys = state.lastRenderedDeviceKeys.map(k => parseOrderDeviceKey(k).orderId);
      const uniquePageOrderIds = Array.from(new Set(pageKeys));
      const selectedOnPage = uniquePageOrderIds.filter(k => state.selectedOrderIds.has(k)).length;
      const allSelected = uniquePageOrderIds.length > 0 && selectedOnPage === uniquePageOrderIds.length;
      const noneSelected = selectedOnPage === 0;
      return { allSelected, noneSelected, selectedOnPage, totalOnPage: uniquePageOrderIds.length };
    }
    function updateSelectAllCheckboxUI() {
      const cb = document.getElementById("select-all-orders");
      if (!cb) return;
      const { allSelected, noneSelected } = computeSelectAllState();
      cb.checked = allSelected;
      cb.indeterminate = !allSelected && !noneSelected;
    }
    // ----------------------------
    // SPEC: BULK OPS
    // ----------------------------
    async function updateOrderStatusInline(orderId, newStatus, options = {}) {
      const body = { status: newStatus, ...(options?.body || {}) };
      if (options?.notifyCustomer === false) body.notifyCustomer = false;
      return apiPut(`/orders/${orderId}/status`, body);
    }
    async function handleBulkStatusUpdate() {
      const sel = document.getElementById("bulkStatusSelect");
      const newStatus = sel?.value || "";
      if (!newStatus) return;
      if (state.selectedOrderIds.size === 0) return;
      const keys = Array.from(state.selectedOrderIds);
      const failures = [];
      let ok = 0;
      for (const k of keys) {
        const orderId = k;
        try {
          await updateOrderStatusInline(orderId, newStatus, { notifyCustomer: false });
          ok++;
        } catch (e) {
          failures.push({ k, orderId, err: e?.message || String(e) });
        }
      }
      if (failures.length) {
        toast(`Bulk status: ${ok} ok, ${failures.length} failed`, "error");
        // keep only failed selected
        state.selectedOrderIds = new Set(failures.map(f => f.k));
      } else {
        toast(`Bulk status updated (${ok})`, "success");
        state.selectedOrderIds.clear();
        if (sel) sel.value = "";
      }
      filterAndRenderOrders(state.currentActiveStatus, state.currentSearchTerm, { preservePage: true });
    }
    async function handleBulkLabelGeneration() {
      if (state.isBulkLabelGenerationInProgress) return;
      if (state.selectedOrderIds.size === 0) return;
      state.isBulkLabelGenerationInProgress = true;
      render();
      const keys = Array.from(state.selectedOrderIds);
      const failures = [];
      let ok = 0;
      for (const k of keys) {
        const orderId = k;
        try {
          await apiPost(`/generate-label/${orderId}`, {});
          ok++;
        } catch (e) {
          failures.push({ k, orderId, err: e?.message || String(e) });
        }
      }
      state.isBulkLabelGenerationInProgress = false;
      if (failures.length) {
        toast(`Generate labels: ${ok} ok, ${failures.length} failed`, "error");
        state.selectedOrderIds = new Set(failures.map(f => f.k));
      } else {
        toast(`Generated labels (${ok})`, "success");
        state.selectedOrderIds.clear();
      }
      filterAndRenderOrders(state.currentActiveStatus, state.currentSearchTerm, { preservePage: true });
    }
    function shouldAutoMarkKitSent(order) {
      // Spec: require >=2 kit label identifiers, not past received, not locked statuses
      const s = normalizeStatusKey(order?.status);
      if (isStatusPastReceived(s)) return false;
      const locked = new Set(["cancelled", "completed", "received"]);
      if (locked.has(s)) return false;
      // ">=2 kit label identifiers" heuristic based on fields commonly present
      const ids = new Set();
      const labels = getShipEngineLabelEntries(order);
      for (const { value: l } of labels) {
        if (l?.labelId) ids.add(String(l.labelId));
        if (l?.label_id) ids.add(String(l.label_id));
        if (l?.id) ids.add(String(l.id));
        if (l?.trackingNumber) ids.add(String(l.trackingNumber));
        if (l?.tracking_number) ids.add(String(l.tracking_number));
      }
      // also include explicit tracking fields
      if (order?.outboundTrackingNumber) ids.add(String(order.outboundTrackingNumber));
      if (order?.inboundTrackingNumber) ids.add(String(order.inboundTrackingNumber));
      return ids.size >= 2;
    }
    async function handleSeparateKitOrders() {
      const src = state.currentFilteredOrders?.length ? state.currentFilteredOrders : getBaseOrdersForStatus("all");
      const eligible = src.filter(shouldAutoMarkKitSent);
      if (!eligible.length) {
        toast("No eligible kit orders found", "info");
        return;
      }
      const ok = confirm(
        `Separate kit orders for ${eligible.length} orders?\n\nThis will set status to "kit_sent" and will NOT notify customers.`
      );
      if (!ok) return;
      let success = 0, failed = 0;
      for (const o of eligible) {
        try {
          await updateOrderStatusInline(o.id, "kit_sent", { notifyCustomer: false });
          // keep local in sync (optimistic)
          o.status = "kit_sent";
          success++;
        } catch (e) {
          failed++;
        }
      }
      toast(`Separate Kit Orders: ${success} ok, ${failed} failed`, failed ? "error" : "success");
      filterAndRenderOrders(state.currentActiveStatus, state.currentSearchTerm, { preservePage: true });
    }
    // ----------------------------
    // SPEC: REFRESH ALL TRACKING (kit/email) with concurrency=4
    // ----------------------------
    const MAX_CONCURRENT_TRACKING_REQUESTS = 4;
    async function refreshTrackingForOrders(type, buttonEl) {
      const t = type === "kit" ? "kit" : "email";
      const base = state.currentFilteredOrders?.length ? state.currentFilteredOrders : getBaseOrdersForStatus("all");
      const candidates = base.filter(o => {
        if (isStatusPastReceived(o?.status)) return false;
        if (t === "kit") {
          if (!matchesKitTrackingHints(o)) return false;
          return hasKitTrackingNumbers(o);
        } else {
          if (!matchesEmailTrackingHints(o)) return false;
          return hasEmailTrackingNumbers(o);
        }
      });
      if (!candidates.length) {
        toast(`No ${t} tracking candidates found`, "info");
        return;
      }
      const ok = confirm(`Refresh ${t.toUpperCase()} tracking for ${candidates.length} orders?`);
      if (!ok) return;
      const originalText = buttonEl?.textContent;
      if (buttonEl) {
        buttonEl.disabled = true;
        buttonEl.textContent = "Refreshing…";
      }
      const queue = candidates.slice();
      let success = 0, skipped = 0, failed = 0;
      const samples = { failed: [], skipped: [] };
      async function worker() {
        while (queue.length) {
          const order = queue.shift();
          if (!order) return;
          try {
            await apiPost(`/refresh-tracking`, { orderId: order.id, type: t });
            success++;
          } catch (e) {
            failed++;
            if (samples.failed.length < 5) samples.failed.push(`#${order.id}: ${e?.message || "failed"}`);
          }
        }
      }
      const workers = Array.from({ length: Math.min(MAX_CONCURRENT_TRACKING_REQUESTS, candidates.length) }, () => worker());
      await Promise.all(workers);
      state.lastRefreshAt = new Date();
      if (buttonEl) {
        buttonEl.disabled = false;
        buttonEl.textContent = originalText || "Refresh";
      }
      alert(
        `Refresh ${t} tracking complete.\n\n` +
        `Success: ${success}\n` +
        `Failed: ${failed}\n\n` +
        (samples.failed.length ? `Failed samples:\n- ${samples.failed.join("\n- ")}\n` : "")
      );
      filterAndRenderOrders(state.currentActiveStatus, state.currentSearchTerm, { preservePage: true });
    }
    // ----------------------------
    // SPEC: VOID LABELS + CANCEL FLOW (best-effort implementation)
    // ----------------------------
    function getLabelOptions(order) {
      // Returns array of { key, id, label }
      const opts = [];
      const seenIds = new Set();
      for (const { key, value } of getShipEngineLabelEntries(order)) {
        const status = String(value?.voidStatus || value?.status || value?.state || "active").toLowerCase();
        if (status === "voided" || value?.voidedAt) continue;
        const id = value?.labelId || value?.label_id || value?.id;
        if (!id || seenIds.has(String(id))) continue;
        seenIds.add(String(id));
        const tracking = value?.trackingNumber || value?.tracking_number || "";
        const display = value?.displayName || key || "ShipEngine Label";
        opts.push({ key: String(key), id: String(id), label: `${display}${tracking ? ` (${tracking})` : ""}` });
      }
      if (order?.shippingLabelId && !seenIds.has(String(order.shippingLabelId))) {
        opts.push({ key: "primary", id: String(order.shippingLabelId), label: "Primary Label" });
        seenIds.add(String(order.shippingLabelId));
      }
      if (order?.easypostLabelId && !seenIds.has(String(order.easypostLabelId))) {
        opts.push({ key: "easypost", id: String(order.easypostLabelId), label: "EasyPost Label" });
      }
      return opts;
    }
    async function requestVoidLabels(orderId, selections) {
      // selections: [{ key, id }]
      if (!Array.isArray(selections) || selections.length === 0) {
        return { ok: false, message: "Please select at least one label to void." };
      }
      return apiPost(`/orders/${orderId}/void-label`, { labels: selections });
    }
    function summarizeVoidResults(result) {
      const msg = result?.message || "";
      return msg || "Void labels requested.";
    }
    async function handleCancelOrder(order) {
      try {
        const options = getLabelOptions(order);
        if (options.length) {
          // pre-cancel void attempt: void all discovered options
          const selections = options.map(o => ({ key: o.key, id: o.id }));
          try {
            const voidRes = await requestVoidLabels(order.id, selections);
            const summary = summarizeVoidResults(voidRes);
            // if summary contains warning-like words, show as error-ish toast
            if (/warn|fail|error|unable|partial/i.test(summary)) toast(summary, "error");
            else toast(summary, "success");
          } catch (e) {
            toast(`Pre-cancel void failed: ${e?.message || "error"}`, "error");
          }
        }
        await apiPost(`/orders/${order.id}/cancel`, { voidLabels: true });
        toast("Order cancelled", "success");
      } catch (e) {
        toast(`Cancel failed: ${e?.message || "error"}`, "error");
      }
    }
    // ----------------------------
    // SPEC: MODAL ACTION SWITCH (exact endpoints)
    // ----------------------------
    async function printPackingSlip(orderId) {
      const user = auth.currentUser;
      const token = user ? await user.getIdToken() : null;
      const res = await fetch(`${API_BASE_URL}/packing-slip/${orderId}`, {
        method: "GET",
        headers: token ? { Authorization: `Bearer ${token}` } : {},
      });
      if (!res.ok) throw new Error("Failed to generate packing slip");
      const blob = await res.blob();
      const url = URL.createObjectURL(blob);
      window.open(url, "_blank", "noopener,noreferrer");
      setTimeout(() => URL.revokeObjectURL(url), 10000);
    }

    async function handleAction(orderId, actionType, options = {}) {
      try {
        // tracking guard
        const order = state.allOrders.find(o => o.id === orderId);
        if ((actionType === "refreshKitTracking" || actionType === "refreshEmailTracking") && order && isStatusPastReceived(order.status)) {
          toast("Skipping tracking refresh: order is past received", "info");
          return;
        }
        let endpoint = "";
        let method = "POST";
        let body = options?.body ?? null;
        switch (actionType) {
          case "generateLabel":
            endpoint = `/generate-label/${orderId}`;
            method = "POST";
            body = {};
            break;
          case "markReceived":
            endpoint = `/orders/${orderId}/status`;
            method = "PUT";
            body = { status: "received", ...(options?.body || {}) };
            break;
          case "markCompleted":
            endpoint = `/orders/${orderId}/status`;
            method = "PUT";
            body = { status: "completed", ...(options?.body || {}) };
            break;
          case "sendReturnLabel":
            endpoint = `/orders/${orderId}/return-label`;
            method = "POST";
            body = {};
            break;
          case "markKitSent":
            endpoint = `/orders/${orderId}/mark-kit-sent`;
            method = "POST";
            body = {};
            break;
          case "sendReviewRequest":
            endpoint = `/orders/${orderId}/send-review-request`;
            method = "POST";
            body = {};
            break;
          case "autoRequote":
            endpoint = `/orders/${orderId}/auto-requote`;
            method = "POST";
            body = {}; // ensured non-null
            break;
          case "refreshKitTracking":
            endpoint = `/refresh-tracking`;
            method = "POST";
            body = { orderId, type: "kit" };
            break;
          case "refreshEmailTracking":
            endpoint = `/refresh-tracking`;
            method = "POST";
            body = { orderId, type: "email" };
            break;
          case "cancelOrder":
            // uses /orders/{id}/cancel, caller can pass { body:{voidLabels:true} } etc
            endpoint = `/orders/${orderId}/cancel`;
            method = "POST";
            body = options?.body ?? {};
            break;
          case "deleteOrder":
            endpoint = `/orders/${orderId}`;
            method = "DELETE";
            body = null;
            break;
          // condition email (exact)
          case "sendConditionEmail":
            endpoint = `/orders/${orderId}/send-condition-email`;
            method = "POST";
            body = options?.body ?? {}; // { reason, notes?, label? }
            break;
          // re-offer (exact)
          case "reOffer":
            endpoint = `/orders/${orderId}/re-offer`;
            method = "POST";
            body = options?.body ?? {}; // { newPrice, reasons, comments }
            break;
          // New Actions from JSON Spec
          case "manualFulfill":
            // "Order Manually Fulfilled" -> usually implies marking it completed or kit sent without generating label
            // For now, prompt for intended status or set to kit_sent/completed?
            // Spec says "Order Manually Fulfilled", typically this means "mark as completed" in simple systems, 
            // or "kit sent" manually. I'll default to marking kit sent for now or completed if the user confirms.
            const manualOk = confirm("Mark this order as manually fulfilled (completed)?");
            if(!manualOk) return;
            endpoint = `/orders/${orderId}/status`;
            method = "PUT";
            body = { status: "completed", manual: true };
            break;
          case "emailBalance":
            endpoint = `/orders/${orderId}/send-condition-email`;
            method = "POST";
            body = { reason: "outstanding_balance", label: "Email Outstanding Balance Notice" };
            break;
          case "emailLocked":
            endpoint = `/orders/${orderId}/send-condition-email`;
            method = "POST";
            body = { reason: "password_locked", label: "Email Password Lock Notice" };
            break;
          case "emailStolen":
            endpoint = `/orders/${orderId}/send-condition-email`;
            method = "POST";
            body = { reason: "stolen", label: "Email Lost/Stolen Notice" };
            break;
          case "emailFmi":
            endpoint = `/orders/${orderId}/send-condition-email`;
            method = "POST";
            body = { reason: "fmi_active", label: "Email FMI / Activation Lock Notice" };
            break;
          case "markPaid":
          case "payNow":
            // Re-offered accepted payment flow
            endpoint = `/orders/${orderId}/status`;
            method = "PUT";
            body = { status: "completed" };
            break;
          case "printDocs":
            toast("Print Kit Docs is not available in this view", "info");
            return;
          case "printPacking":
            await printPackingSlip(orderId);
            return;
          case "voidLabels":
              // Just a UI trigger to switch tab, no API call here directly unless submitted
              // But if we want to trigger the void modal logic:
              // The caller usually handles UI. If here, maybe trigger generic void?
              // I'll leave this as a UI-only handler in the event listener, but if it reaches here:
              return; 
          case "clearData":
              // Placeholder for "Clear Saved Shipping Data"
              toast("Clear data not implemented", "info");
              return;
          default:
            toast(`Unknown action: ${actionType}`, "error");
            return;
        }
        if (method === "GET") await apiGet(endpoint);
        else if (method === "POST") await apiPost(endpoint, body ?? {});
        else if (method === "PUT") await apiPut(endpoint, body ?? {});
        else if (method === "DELETE") await apiDelete(endpoint);
        toast(`Action ${actionType} success`, "success");
        // refresh order data by re-running filter (Firestore will also push updates)
        filterAndRenderOrders(state.currentActiveStatus, state.currentSearchTerm, { preservePage: true });
      } catch (e) {
        console.error(e);
        toast(`Action failed: ${e.message}`, "error");
      }
    }
    async function saveQc(orderId, deviceKey, qcData) {
      try {
        const orderRef = doc(db, "orders", orderId);
        const safeDeviceKey = deviceKey || buildOrderDeviceKey(orderId, 0);
        try {
          await updateDoc(orderRef, {
            [`qcDataByDevice.${safeDeviceKey}`]: qcData,
            ...(safeDeviceKey.endsWith("::0") ? { qcData } : {}),
            status: "received",
            qcCompletedAt: new Date()
          });
        } catch (e) {
          await setDoc(orderRef, {
            qcDataByDevice: { [safeDeviceKey]: qcData },
            ...(safeDeviceKey.endsWith("::0") ? { qcData } : {}),
            status: "received",
            qcCompletedAt: new Date()
          }, { merge: true });
        }
        toast("QC saved", "success");
      } catch (e) {
        console.error(e);
        toast("Failed to save QC", "error");
      }
    }

    async function processQcOutcome(order, qcData) {
      const emailActions = [];
      if (qcData?.isLocked === "yes") emailActions.push("emailLocked");
      if (qcData?.hasFmi === "yes") emailActions.push("emailFmi");
      if (qcData?.hasBalance === "yes") emailActions.push("emailBalance");

      for (const action of emailActions) {
        try {
          await handleAction(order.id, action);
        } catch (err) {
          console.error("QC auto-email failed", action, err);
        }
      }

      if (emailActions.length) {
        await updateOrderStatusInline(order.id, "emailed", {
          notifyCustomer: false,
          body: { qcAwaitingResponse: true }
        });
      }

      return { sentEmails: emailActions.length > 0 };
    }
    // ----------------------------
    // RENDER: LOGIN
    // ----------------------------
    function renderLogin() {
      return `
        <div class="min-h-screen bg-slate-50 flex flex-col justify-center py-12 sm:px-6 lg:px-8">
          <div class="sm:mx-auto sm:w-full sm:max-w-md">
            <div class="flex justify-center">
              <div class="w-12 h-12 bg-indigo-600 rounded-xl flex items-center justify-center text-white font-bold text-xl shadow-lg shadow-indigo-200">BB</div>
            </div>
          </div>
          <div class="mt-8 sm:mx-auto sm:w-full sm:max-w-md">
            <div class="bg-white py-8 px-4 shadow-xl shadow-slate-200 border border-slate-100 sm:rounded-xl sm:px-10">
              <form id="loginForm" class="space-y-6">
                <div>
                  <label class="block text-sm font-medium text-slate-700">Email address</label>
                  <div class="mt-1 relative rounded-md shadow-sm">
                    <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                      <i data-lucide="mail" class="h-5 w-5 text-slate-400"></i>
                    </div>
                    <input id="loginEmail" type="email" required autocomplete="email"
                      class="block w-full pl-10 sm:text-sm border-slate-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 py-2.5"
                      placeholder="admin@example.com" />
                  </div>
                </div>
                <div>
                  <label class="block text-sm font-medium text-slate-700">Password</label>
                  <div class="mt-1 relative rounded-md shadow-sm">
                    <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                      <i data-lucide="lock" class="h-5 w-5 text-slate-400"></i>
                    </div>
                    <input id="loginPassword" type="password" required autocomplete="current-password"
                      class="block w-full pl-10 sm:text-sm border-slate-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 py-2.5"
                      placeholder="••••••••" />
                  </div>
                </div>
                <div id="loginError" class="hidden rounded-md bg-rose-50 p-4">
                  <div class="flex">
                    <div class="flex-shrink-0"><i data-lucide="alert-circle" class="h-5 w-5 text-rose-400"></i></div>
                    <div class="ml-3"><h3 class="text-sm font-medium text-rose-800">Invalid email or password. Please try again.</h3></div>
                  </div>
                </div>
                <div>
                  <button id="loginBtn" type="submit"
                    class="w-full flex justify-center py-2.5 px-4 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-70 transition-all">
                    <span id="loginBtnText">Sign in</span>
                    <span id="loginSpinner" class="hidden"><i data-lucide="refresh-cw" class="h-5 w-5 animate-spin"></i></span>
                  </button>
                </div>
              </form>
            </div>
          </div>
        </div>
      `;
    }
    function bindLogin() {
      const form = document.getElementById("loginForm");
      const emailEl = document.getElementById("loginEmail");
      const passEl = document.getElementById("loginPassword");
      const errEl = document.getElementById("loginError");
      const btn = document.getElementById("loginBtn");
      const btnText = document.getElementById("loginBtnText");
      const spinner = document.getElementById("loginSpinner");
      form.addEventListener("submit", async (e) => {
        e.preventDefault();
        errEl.classList.add("hidden");
        btn.disabled = true;
        btnText.classList.add("hidden");
        spinner.classList.remove("hidden");
        try {
          await signInWithEmailAndPassword(auth, emailEl.value, passEl.value);
        } catch (err) {
          console.error(err);
          errEl.classList.remove("hidden");
          btn.disabled = false;
          btnText.classList.remove("hidden");
          spinner.classList.add("hidden");
        }
      });
    }
    // ----------------------------
    // RENDER: APP SHELL
    // ----------------------------
    function renderSidebar() { return ""; }
    function renderTopbar() {
      const initial = state.user?.email ? state.user.email.charAt(0).toUpperCase() : "A";
      return `
        <header class="h-16 bg-white border-b border-slate-200 sticky top-0 z-10 px-4 sm:px-8 flex items-center justify-between gap-4">
          <div class="flex items-center gap-3 flex-1">
                        <i data-lucide="search" class="text-slate-400" style="width:20px;height:20px"></i>
            <input id="searchInput" type="text"
              placeholder="Search by ID, customer, device, storage, tracking…"
              class="bg-transparent border-none outline-none text-sm w-full placeholder:text-slate-400"
              value="${esc(state.currentSearchTerm)}" />
          </div>
          <div class="hidden md:flex items-center gap-3">
            <div class="flex items-center gap-2">
              <label class="text-xs font-semibold text-slate-400 uppercase">Promo</label>
              <select id="promoFilterSelect" class="text-sm border border-slate-200 rounded-lg px-2 py-1.5 bg-white">
                <option value="all">All</option>
              </select>
            </div>
            <label class="flex items-center gap-2 text-sm text-slate-600">
              <input id="compactDensityToggle" type="checkbox" class="h-4 w-4 rounded border-slate-300 text-indigo-600" ${state.compactDensity ? "checked" : ""} />
              Compact
            </label>
            <div class="text-xs text-slate-500">
              ${state.lastRefreshAt ? `Updated ${esc(formatTimeOnly(state.lastRefreshAt))}` : ""}
            </div>
          </div>
          <div class="flex items-center gap-4">
            <button id="logoutBtn" class="p-2 text-rose-600 hover:bg-rose-50 rounded-full transition-colors" title="Sign out">
              <i data-lucide="log-out" style="width:18px;height:18px"></i>
            </button>
            <div class="h-8 w-8 rounded-full bg-indigo-100 border border-indigo-200 flex items-center justify-center text-xs font-bold text-indigo-700">
              ${esc(initial)}
            </div>
          </div>
        </header>
      `;
    }
    // ----------------------------
    // SPEC: STATUS COUNTS + METRICS
    // ----------------------------
    function computeStatusCounts() {
      const { visible, cancelled } = splitCancelled(state.allOrders);
      const statusCounts = new Map();
      for (const o of visible) {
        const s = normalizeStatusKey(o?.status) || "unknown";
        statusCounts.set(s, (statusCounts.get(s) || 0) + 1);
      }
      const statusCountAll = visible.length;
      const cancelledCount = cancelled.length;
      // live orders = visible excluding completed + return-label-generated
      const liveOrders = visible.filter(o => {
        const s = normalizeStatusKey(o?.status);
        return s !== "completed" && s !== "return-label-generated";
      }).length;
      return { statusCounts, statusCountAll, cancelledCount, liveOrders, visible };
    }
    function updateGlassMetricsHTML() {
      const now = new Date();
      const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
      const { visible } = splitCancelled(state.allOrders);
      const ordersToday = visible.filter(o => (toDateAny(o?.createdAt)?.getTime() || 0) >= todayStart).length;
      const initialOrderCount = visible.filter(o => Number(o?.estimatedQuote || 0) > 0).length;
      const completedOrdersCount = visible.filter(o => {
        const s = normalizeStatusKey(o?.status);
        return s === "completed" || s === "re-offered-accepted";
      }).length;
      const conversionRate = initialOrderCount ? Math.round((completedOrdersCount / initialOrderCount) * 100) : 0;
      const receivedDevicesCount = visible.filter(o => isReceivedStatusValue(o?.status)).length;
      return `
        <div class="grid grid-cols-1 md:grid-cols-5 gap-3 mb-6">
          <div class="bg-white p-4 rounded-xl border border-slate-200 shadow-sm">
            <div class="text-[11px] font-semibold text-slate-500 uppercase">Orders Today</div>
            <div class="text-2xl font-bold">${ordersToday}</div>
          </div>
          <div class="bg-white p-4 rounded-xl border border-slate-200 shadow-sm">
            <div class="text-[11px] font-semibold text-slate-500 uppercase">Initial Quotes</div>
            <div class="text-2xl font-bold">${initialOrderCount}</div>
          </div>
          <div class="bg-white p-4 rounded-xl border border-slate-200 shadow-sm">
            <div class="text-[11px] font-semibold text-slate-500 uppercase">Completed</div>
            <div class="text-2xl font-bold">${completedOrdersCount}</div>
          </div>
          <div class="bg-white p-4 rounded-xl border border-slate-200 shadow-sm">
            <div class="text-[11px] font-semibold text-slate-500 uppercase">Conversion</div>
            <div class="text-2xl font-bold">${conversionRate}%</div>
          </div>
          <div class="bg-white p-4 rounded-xl border border-slate-200 shadow-sm">
            <div class="text-[11px] font-semibold text-slate-500 uppercase">Received</div>
            <div class="text-2xl font-bold">${receivedDevicesCount}</div>
          </div>
        </div>
      `;
    }
    function getStatusPillClasses(key, isActive) {
      // NOTE: Keep these class strings static so Tailwind can detect them during build.
      const s = normalizeStatusKey(key);
      if (s === "all") {
        return {
          pill: isActive ? "bg-slate-900 text-white shadow-md" : "bg-white text-slate-600 border border-slate-200 hover:bg-slate-50",
          count: isActive ? "bg-white/15 text-white" : "bg-slate-100 text-slate-600"
        };
      }
      if (s === "cancelled") {
        return {
          pill: isActive ? "bg-slate-700 text-white shadow-md" : "bg-slate-100 text-slate-600 border border-slate-200 hover:bg-slate-200",
          count: isActive ? "bg-white/15 text-white" : "bg-white/70 text-slate-600"
        };
      }
      if (s === "order_pending" || s === "kit_needs_printing") {
        return {
          pill: isActive ? "bg-amber-500 text-white shadow-md" : "bg-amber-50 text-amber-700 border border-amber-200 hover:bg-amber-100",
          count: isActive ? "bg-white/15 text-white" : "bg-amber-100 text-amber-700"
        };
      }
      if (s === "label_generated") {
        return {
          pill: isActive ? "bg-blue-500 text-white shadow-md" : "bg-blue-50 text-blue-700 border border-blue-200 hover:bg-blue-100",
          count: isActive ? "bg-white/15 text-white" : "bg-blue-100 text-blue-700"
        };
      }
      if (s === "emailed" || s === "received") {
        return {
          pill: isActive ? "bg-indigo-500 text-white shadow-md" : "bg-indigo-50 text-indigo-700 border border-indigo-200 hover:bg-indigo-100",
          count: isActive ? "bg-white/15 text-white" : "bg-indigo-100 text-indigo-700"
        };
      }
      if (s === "completed") {
        return {
          pill: isActive ? "bg-emerald-500 text-white shadow-md" : "bg-emerald-50 text-emerald-700 border border-emerald-200 hover:bg-emerald-100",
          count: isActive ? "bg-white/15 text-white" : "bg-emerald-100 text-emerald-700"
        };
      }
      return {
        pill: isActive ? "bg-slate-700 text-white shadow-md" : "bg-slate-100 text-slate-600 border border-slate-200 hover:bg-slate-200",
        count: isActive ? "bg-white/15 text-white" : "bg-white/70 text-slate-600"
      };
    }
    function renderStatusBreakdown() {
      const { statusCounts, statusCountAll, cancelledCount, visible } = computeStatusCounts();
      const items = [
        { key: "all", label: "All", count: statusCountAll },
        { key: "order_pending", label: "Order Pending", count: statusCounts.get("order_pending") || 0 },
        { key: "kit_needs_printing", label: "Kit Needs Printing", count: visible.filter(o => KIT_PRINT_PENDING_STATUSES.has(normalizeStatusKey(o?.status))).length },
        { key: "label_generated", label: "Label Generated", count: visible.filter(isLabelGenerationStage).length },
        { key: "emailed", label: "Emailed", count: visible.filter(o => isBalanceEmailStatus(o) || normalizeStatusKey(o?.status)==="emailed").length },
        { key: "received", label: "Received", count: visible.filter(o => isReceivedStatusValue(o?.status)).length },
        { key: "completed", label: "Completed", count: statusCounts.get("completed") || 0 },
        { key: "cancelled", label: "Cancelled", count: cancelledCount },
      ];
      return `
        <div class="flex items-center gap-2 overflow-x-auto pb-2 scrollbar-hide mb-4">
          ${items.map(it => `
            ${(() => {
              const classes = getStatusPillClasses(it.key, state.currentActiveStatus === it.key);
              return `
            <button data-status-tab="${esc(it.key)}"
              class="px-4 py-2 rounded-full text-sm font-semibold whitespace-nowrap transition-all ${classes.pill}"
              role="button" tabindex="0">
              ${esc(it.label)}
              <span class="ml-2 inline-flex items-center justify-center min-w-[28px] px-2 py-0.5 rounded-full text-xs ${classes.count}">${it.count}</span>
            </button>
              `;
            })()}
          `).join("")}
        </div>
      `;
    }
    // ----------------------------
    // SPEC: ORDERS TABLE RENDER (with per-device rows + selection)
    // ----------------------------
    function renderBulkBar() {
      return `
        <div class="bg-white border border-slate-200 rounded-xl shadow-sm p-4 mb-4">
          <div class="flex flex-col lg:flex-row lg:items-center gap-3 justify-between">
            <div class="flex flex-wrap items-center gap-2">
              <button id="refresh-all-kit-tracking"
                class="bg-white border border-slate-200 text-slate-700 hover:bg-slate-50 px-3 py-2 rounded-lg text-sm font-semibold flex items-center gap-2">
                <i data-lucide="refresh-cw" style="width:16px;height:16px"></i> Refresh All Kit Tracking
              </button>
              <button id="refresh-all-email-tracking"
                class="bg-white border border-slate-200 text-slate-700 hover:bg-slate-50 px-3 py-2 rounded-lg text-sm font-semibold flex items-center gap-2">
                <i data-lucide="refresh-cw" style="width:16px;height:16px"></i> Refresh All Email Tracking
              </button>
              <button id="separate-kit-orders"
                class="bg-white border border-slate-200 text-slate-700 hover:bg-slate-50 px-3 py-2 rounded-lg text-sm font-semibold flex items-center gap-2">
                <i data-lucide="split" style="width:16px;height:16px"></i> Separate Kit Orders
              </button>
              <button id="open-order-text-import"
                class="bg-white border border-slate-200 text-slate-700 hover:bg-slate-50 px-3 py-2 rounded-lg text-sm font-semibold flex items-center gap-2">
                <i data-lucide="file-text" style="width:16px;height:16px"></i> Paste Order From Text
              </button>
            </div>
            <div class="flex flex-col sm:flex-row gap-2 sm:items-center">
              <button id="bulk-generate-labels"
                class="px-3 py-2 rounded-lg text-sm font-semibold flex items-center gap-2 ${
                  (state.selectedOrderIds.size > 0 && !state.isBulkLabelGenerationInProgress)
                    ? "bg-indigo-600 hover:bg-indigo-700 text-white shadow-md shadow-indigo-200"
                    : "bg-slate-100 text-slate-400 cursor-not-allowed"
                }"
                ${!(state.selectedOrderIds.size > 0 && !state.isBulkLabelGenerationInProgress) ? "disabled" : ""}>
                <i data-lucide="${state.isBulkLabelGenerationInProgress ? "loader" : "tag"}" class="${state.isBulkLabelGenerationInProgress ? "animate-spin" : ""}" style="width:16px;height:16px"></i>
                ${state.isBulkLabelGenerationInProgress ? "Generating…" : "Generate Labels For Selected"}
              </button>
              <button id="bulk-delete-orders" class="px-3 py-2 rounded-lg text-sm font-semibold ${state.selectedOrderIds.size > 0 ? "bg-rose-600 hover:bg-rose-700 text-white" : "bg-slate-100 text-slate-400 cursor-not-allowed"}" ${state.selectedOrderIds.size > 0 ? "" : "disabled"}>Delete Selected Orders</button>
              <div class="flex items-center gap-2">
                <select id="bulkStatusSelect" class="border border-slate-200 rounded-lg px-2 py-2 text-sm bg-white">
                  <option value="">Bulk update status…</option>
                  ${STATUS_DROPDOWN_OPTIONS.map(s => `<option value="${esc(s)}">${esc(formatStatusLabel(s))}</option>`).join("")}
                </select>
                <button id="bulk-status-apply"
                  class="px-3 py-2 rounded-lg text-sm font-semibold ${
                    (state.selectedOrderIds.size > 0) ? "bg-slate-900 hover:bg-slate-800 text-white" : "bg-slate-100 text-slate-400 cursor-not-allowed"
                  }"
                  ${state.selectedOrderIds.size > 0 ? "" : "disabled"}>
                  Update
                </button>
              </div>
            </div>
          </div>
          <div class="mt-3 text-xs text-slate-500 flex items-center justify-between">
            <div>Selected orders: <span class="font-semibold text-slate-700">${state.selectedOrderIds.size}</span></div>
            ${IS_AGING_PAGE ? `<div class="text-amber-700 font-semibold">Aging mode ON (min age: ${Math.round(MIN_AGING_MS / (1000*60*60*24))}d)</div>` : `<div></div>`}
          </div>
        </div>
      `;
    }
    function promoBadgeHTML(order) {
      const code = extractOrderPromoCode(order);
      if (!code) return "";
      const bonus = getPromoBonusAmount(order);
      return `
        <span class="inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-[11px] font-semibold bg-emerald-50 text-emerald-700 border border-emerald-100">
          Promo ${esc(code)}${bonus ? ` (+$${esc(Number(bonus).toFixed(2))})` : ""}
        </span>
      `;
    }
    function labelStatusExtraHTML(order) {
      // show small details about kit/label tracking statuses if present
      const kitTN = order?.kitTrackingStatus?.trackingNumber || order?.kitTrackingStatus?.tracking_number || "";
      const labTN = order?.labelTrackingStatus?.trackingNumber || order?.labelTrackingStatus?.tracking_number || "";
      const parts = [];
      if (kitTN) parts.push(`Kit: ${esc(kitTN)}`);
      if (labTN) parts.push(`Label: ${esc(labTN)}`);
      return parts.join(" • ");
    }
    function renderOrdersTable() {
      const source = state.currentFilteredOrders?.length ? state.currentFilteredOrders : getBaseOrdersForStatus("all");
      const total = source.length;
      const totalPages = Math.max(1, Math.ceil(total / state.ORDERS_PER_PAGE));
      const page = Math.min(Math.max(1, state.currentPage), totalPages);
      const start = (page - 1) * state.ORDERS_PER_PAGE;
      const end = start + state.ORDERS_PER_PAGE;
      const pageOrders = source.slice(start, end);
      // build per-device rows & track lastRenderedDeviceKeys
      state.lastRenderedDeviceKeys = [];
      const rowHtml = [];
      for (const order of pageOrders) {
        const entries = getOrderDeviceEntries(order);
        const createdAt = order?.createdAt;
        const lastUp = getLastUpdateTimestamp(order);
        const trackingNumber = getAnyTrackingNumber(order) || "";
        const trackingLink = trackingNumber ? `https://tools.usps.com/go/TrackConfirmAction?tLabels=${encodeURIComponent(trackingNumber)}` : "";
        const statusExtra = labelStatusExtraHTML(order);
        const payoutTotal = getOrderPayoutTotal(order);
        state.lastRenderedDeviceKeys.push(buildOrderDeviceKey(order.id, 0));

        // Order summary row
        rowHtml.push(`
          <tr class="bg-slate-50/70 border-t border-slate-200 cursor-pointer" data-order-row="${esc(order.id)}">
            <td class="px-4 py-3 align-top">
              <div class="flex items-start gap-3">
                <input type="checkbox" data-order-checkbox="${esc(order.id)}" class="h-4 w-4 rounded border-slate-300 text-indigo-600 mt-1" ${state.selectedOrderIds.has(order.id) ? "checked" : ""} />
                <span class="inline-block w-1.5 h-8 rounded-full ${getStatusAccentBgClass(order.status)}" aria-hidden="true"></span>
              </div>
            </td>
            <td class="px-4 py-3 align-top">
              <div class="flex flex-col gap-1">
                <div class="flex items-center gap-2 flex-wrap">
                  <span class="font-bold text-slate-900">#${esc(order.id)}</span>
                  <span class="text-xs text-slate-500">${esc(formatDate(createdAt))}</span>
                  <span class="text-xs text-slate-400">•</span>
                  <span class="text-xs text-slate-500">${esc(getOrderAge(createdAt))}</span>
                  ${promoBadgeHTML(order)}
                </div>
                <div class="text-xs text-slate-500">
                  <span class="font-semibold text-slate-700">${esc(order?.shippingInfo?.fullName || "Guest")}</span>
                  ${order?.shippingInfo?.phone ? ` • <span>${esc(order.shippingInfo.phone)}</span>` : ""}
                  ${order?.shippingInfo?.email ? ` • <span>${esc(order.shippingInfo.email)}</span>` : ""}
                </div>
                <div class="text-sm text-slate-800 font-semibold mt-1">
                  ${esc(entries.length)} device${entries.length === 1 ? "" : "s"} • Payout <span class="text-emerald-700">$${esc(Number(payoutTotal || 0).toFixed(2))}</span>
                </div>
                ${lastUp ? `<div class="text-[11px] text-slate-400">Last update: ${esc(formatDate(lastUp))}</div>` : ""}
              </div>
            </td>
            <td class="px-4 py-3 align-top">
              ${statusBadgeHTML(order.status, statusExtra)}
            </td>
            <td class="px-4 py-3 align-top">
              ${trackingNumber ? `
                <a class="text-sm font-semibold text-indigo-700 hover:underline" href="${trackingLink}" target="_blank" rel="noreferrer">
                  ${esc(trackingNumber)}
                </a>
              ` : `<span class="text-sm text-slate-400">N/A</span>`}
            </td>
            <td class="px-4 py-3 align-top">
              <div class="flex flex-wrap gap-2 justify-end">
                <span class="text-xs text-slate-400">Click row to open</span>
                <button type="button" data-view-order="${esc(order.id)}" class="px-3 py-1.5 rounded-lg text-xs font-semibold bg-slate-900 text-white hover:bg-slate-800">
                  View
                </button>
              </div>
            </td>
          </tr>
        `);

        // Device rows
        if (state.expandedOrderIds.has(order.id)) for (const entry of entries) {
          const deviceKey = buildOrderDeviceKey(order.id, entry.deviceIndex);
          state.lastRenderedDeviceKeys.push(deviceKey);
          const item = entry.item || {};
          const deviceTitle = item.device || order.device || "(Unknown device)";
          const deviceSub = [
            item.model || order.model || "",
            item.storage || order.storage || "",
            item.carrier || order.carrier || "",
            item.condition || order.condition || ""
          ].filter(Boolean).join(" • ");
          rowHtml.push(`
            <tr class="hover:bg-slate-50 transition-colors">
              <td class="px-4 py-3 align-top">
                <div class="flex items-center gap-3">
                  <span class="w-6 text-slate-300 font-black" aria-hidden="true">↳</span>

                </div>
              </td>
              <td class="px-4 py-3 align-top">
                <div class="min-w-0">
                  <div class="text-xs text-slate-400 font-bold uppercase tracking-wider">Device ${esc(entry.deviceIndex + 1)}</div>
                  <div class="text-sm text-slate-900 mt-1 font-semibold truncate">${esc(deviceTitle)}</div>
                  ${deviceSub ? `<div class="text-xs text-slate-500 truncate">${esc(deviceSub)}</div>` : ""}
                </div>
              </td>
              <td class="px-4 py-3 align-top"><span class="text-sm text-slate-300">—</span></td>
              <td class="px-4 py-3 align-top"><span class="text-sm text-slate-300">—</span></td>
              <td class="px-4 py-3 align-top">
                <div class="flex flex-wrap gap-2 justify-end">
                  <button type="button" data-view-device="${esc(deviceKey)}"
                    class="px-3 py-1.5 rounded-lg text-xs font-semibold bg-slate-900 text-white hover:bg-slate-800">
                    View
                  </button>
                </div>
              </td>
            </tr>
          `);
        }
      }
      const body = rowHtml.length
        ? rowHtml.join("")
        : `<tr><td colspan="5" class="px-6 py-10 text-center text-slate-500">No orders found.</td></tr>`;
      const densityClass = state.compactDensity ? "density-compact" : "density-default";
      return `
        <div class="bg-white border border-slate-200 rounded-xl shadow-sm overflow-hidden">
          <div class="overflow-x-auto">
            <table class="w-full text-left border-collapse">
              <thead>
                <tr class="bg-slate-50 border-b border-slate-200 text-xs uppercase text-slate-500 font-semibold tracking-wider">
                  <th class="px-4 py-4 w-10">
                    <input id="select-all-orders" type="checkbox" class="h-4 w-4 rounded border-slate-300 text-indigo-600" />
                  </th>
                  <th class="px-4 py-4">Order / Device</th>
                  <th class="px-4 py-4">Status</th>
                  <th class="px-4 py-4">Tracking</th>
                  <th class="px-4 py-4 text-right">Actions</th>
                </tr>
              </thead>
              <tbody id="ordersTableBody" class="divide-y divide-slate-100 ${densityClass}">
                ${body}
              </tbody>
            </table>
          </div>
          <div class="px-6 py-4 border-t border-slate-200 bg-slate-50 flex flex-col sm:flex-row sm:items-center justify-between gap-3">
            <span class="text-xs text-slate-500">
              Showing <b>${Math.min(end, total)}</b> of <b>${total}</b> orders • Page <b>${page}</b> / <b>${totalPages}</b>
            </span>
            <div class="flex gap-2">
              <button data-page="first" class="px-3 py-1.5 border border-slate-300 bg-white rounded text-xs font-semibold hover:bg-slate-50 ${page===1 ? "opacity-50 cursor-not-allowed" : ""}" ${page===1 ? "disabled" : ""}>First</button>
              <button data-page="prev" class="px-3 py-1.5 border border-slate-300 bg-white rounded text-xs font-semibold hover:bg-slate-50 ${page===1 ? "opacity-50 cursor-not-allowed" : ""}" ${page===1 ? "disabled" : ""}>Prev</button>
              <button data-page="next" class="px-3 py-1.5 border border-slate-300 bg-white rounded text-xs font-semibold hover:bg-slate-50 ${page===totalPages ? "opacity-50 cursor-not-allowed" : ""}" ${page===totalPages ? "disabled" : ""}>Next</button>
              <button data-page="last" class="px-3 py-1.5 border border-slate-300 bg-white rounded text-xs font-semibold hover:bg-slate-50 ${page===totalPages ? "opacity-50 cursor-not-allowed" : ""}" ${page===totalPages ? "disabled" : ""}>Last</button>
            </div>
          </div>
        </div>
      `;
    }
    function renderOrdersPage() {
      return `
        <main class="flex-1 p-4 sm:p-6 overflow-y-auto">
          <div class="flex flex-col gap-5">
            <div class="flex flex-col md:flex-row md:items-end justify-between gap-4">
              <div>
                <h2 class="text-2xl font-bold text-slate-900 tracking-tight">${IS_AGING_PAGE ? "Aging Orders" : "Order Management"}</h2>
                <p class="text-sm text-slate-500 mt-1">Filter, bulk-process, and manage fulfillment without breaking backend routes.</p>
              </div>
              <div class="md:hidden flex flex-col gap-2">
                <input id="mobileSearchInput" type="text" value="${esc(state.currentSearchTerm)}"
                  placeholder="Search orders…"
                  class="w-full border border-slate-200 rounded-lg px-3 py-2 text-sm bg-white" />
                <div class="flex items-center gap-2">
                  <select id="promoFilterSelectMobile" class="flex-1 border border-slate-200 rounded-lg px-2 py-2 text-sm bg-white">
                    <option value="all">All</option>
                  </select>
                  <label class="flex items-center gap-2 text-sm text-slate-600">
                    <input id="compactDensityToggleMobile" type="checkbox" class="h-4 w-4 rounded border-slate-300 text-indigo-600" ${state.compactDensity ? "checked" : ""} />
                    Compact
                  </label>
                </div>
              </div>
            </div>
            ${updateGlassMetricsHTML()}
            ${renderStatusBreakdown()}
            ${renderBulkBar()}
            ${renderOrdersTable()}
          </div>
        </main>
      `;
    }
    // ----------------------------
    // DRAWER (kept, but actions/status edit aligned to spec)
    // ----------------------------
    function workflowStepperHTML(order) {
      const status = order.status || "order_pending";
      const hasLabel = !!getAnyTrackingNumber(order) || String(order.status || "").includes("label");
      const hasQc = !!(order.qcData || (order.qcDataByDevice && Object.keys(order.qcDataByDevice).length));
      let activeStep = 0;
      const s = String(status).toLowerCase();
      if (s.includes("completed") || s.includes("paid") || s.includes("re-offered-accepted")) activeStep = 4;
      else if (s.includes("re-offer")) activeStep = 3;
      else if (hasQc || s.includes("received") || s.includes("emailed")) activeStep = 2;
      else if (hasLabel || s.includes("label") || s.includes("transit") || s.includes("delivered_to_us")) activeStep = 1;
      else if (s.includes("pending") || s.includes("printing")) activeStep = 0;
      else if (s.includes("cancel")) activeStep = -1;
      if (activeStep === -1) {
        return `
          <div class="px-6 py-3 bg-rose-50 border-b border-rose-100 flex items-center justify-center gap-2 text-rose-700 font-medium text-sm">
            <i data-lucide="ban" style="width:16px;height:16px"></i> This order has been cancelled.
          </div>
        `;
      }
      const steps = [
        { label: "Pending", icon: "clock" },
        { label: "Label / Transit", icon: "truck" },
        { label: "Received / QC", icon: "shield-check" },
        { label: "Re-Offer", icon: "alert-triangle" },
        { label: "Paid & Done", icon: "check-circle" },
      ];
      const pct = Math.max(0, Math.min(100, (activeStep / (steps.length - 1)) * 100));
      return `
        <div class="px-6 py-4 bg-slate-50/50 border-b border-slate-200">
          <div class="relative flex items-center justify-between w-full max-w-lg mx-auto">
            <div class="absolute left-0 top-1/2 -translate-y-1/2 w-full h-0.5 bg-slate-200 -z-10"></div>
            <div class="absolute left-0 top-1/2 -translate-y-1/2 h-0.5 bg-indigo-600 -z-10 transition-all duration-500" style="width:${pct}%"></div>
            ${steps.map((st, idx) => {
              const isActive = idx <= activeStep;
              const isCurrent = idx === activeStep;
              return `
                <div class="relative z-10 flex flex-col items-center gap-2">
                  <div class="w-8 h-8 rounded-full flex items-center justify-center border-2 transition-all duration-300 ${
                    isActive ? "bg-indigo-600 border-indigo-600 text-white" : "bg-white border-slate-300 text-slate-400"
                  }">
                    <i data-lucide="${st.icon}" style="width:14px;height:14px"></i>
                  </div>
                  <span class="text-[10px] uppercase font-bold tracking-wider absolute -bottom-6 whitespace-nowrap ${
                    isCurrent ? "text-indigo-700" : "text-slate-400"
                  }">${esc(st.label)}</span>
                </div>
              `;
            }).join("")}
          </div>
          <div class="h-4"></div>
        </div>
      `;
    }
    function renderStatusDropdown(order) {
      const open = state.statusDropdownOpen;
      if (!open) return "";
      return `
        <div class="absolute right-0 mt-2 w-64 bg-white border border-slate-200 rounded-xl shadow-xl overflow-hidden z-[1300]">
          <div class="p-2 max-h-72 overflow-y-auto">
            ${STATUS_DROPDOWN_OPTIONS.map(s => `
              <button data-set-status="${esc(s)}"
                class="w-full text-left px-3 py-2 rounded-lg text-sm font-semibold ${
                  normalizeStatusKey(order.status) === normalizeStatusKey(s) ? "bg-indigo-50 text-indigo-700" : "hover:bg-slate-50 text-slate-700"
                }">
                ${esc(formatStatusLabel(s))}
              </button>
            `).join("")}
          </div>
        </div>
      `;
    }
    function renderDrawer(order) {
      const tabs = [
        { id: "overview", label: "Overview", icon: "layout-dashboard" },
        { id: "shipping", label: "Shipping & Tracking", icon: "truck" },
        { id: "logs", label: "Activity Logs", icon: "file-text" },
      ];
      const entries = getOrderDeviceEntries(order);
      const focused = getFocusedDevice(order);
      if (focused.isFocused) tabs.splice(2, 0, { id: "qc", label: "QC & Intake", icon: "shield-check" });
      const visibleEntries = focused.isFocused ? [focused.entry] : entries;
      function overviewHTML() {
        const totalDeviceCount = Math.max(1, entries.length || visibleEntries.length || 1);
        const reofferAccepted = isAcceptedReofferStatus(order?.status);
        const acceptedTotal = getAcceptedReofferPayout(order);
        const originalTotal = getOriginalPayout(order);
        const acceptedPerDevice = Number.isFinite(acceptedTotal) ? (acceptedTotal / totalDeviceCount) : null;
        const originalPerDevice = Number.isFinite(originalTotal) ? (originalTotal / totalDeviceCount) : null;

        const devices = visibleEntries.map((entry) => {
          const item = entry.item || {};
          const offer = getPerDeviceOffer(item, order);
          const showAcceptedOfferSwap = reofferAccepted && Number.isFinite(acceptedPerDevice) && Number.isFinite(originalPerDevice);
          return `
            <div class="p-3.5 flex items-start gap-3 hover:bg-slate-50 transition-colors">
              <div class="h-12 w-12 bg-slate-100 rounded-lg flex items-center justify-center text-slate-400 flex-shrink-0">
                <i data-lucide="smartphone" style="width:24px;height:24px"></i>
              </div>
              <div class="flex-1">
                <h4 class="text-base font-bold text-slate-900 leading-tight">${esc(item.device || order.device || "")}</h4>
                <div class="flex flex-wrap gap-1.5 mt-1.5">
                  <span class="bg-slate-100 px-2 py-0.5 rounded-md text-[11px] font-semibold border border-slate-200">${esc(item.storage || order.storage || "")}</span>
                  <span class="bg-slate-100 px-2 py-0.5 rounded-md text-[11px] font-semibold border border-slate-200">${esc(formatCarrierLabel(item.carrier || order.carrier || ""))}</span>
                  <span class="bg-slate-100 px-2 py-0.5 rounded-md text-[11px] font-semibold border border-slate-200 capitalize">${esc(item.condition || order.condition || "")}</span>
                </div>
              </div>
              <div class="text-right">
                <div class="text-xs text-slate-400 uppercase font-bold tracking-wider mb-1">Offer</div>
                ${showAcceptedOfferSwap ? `
                  <div class="text-sm font-bold text-rose-600 line-through decoration-2 decoration-rose-500">$${esc(Number(originalPerDevice || 0).toFixed(2))}</div>
                  <div class="text-[11px] font-semibold uppercase tracking-wide text-emerald-700 mt-1">New Accepted Offer</div>
                  <div class="text-xl font-extrabold text-emerald-600">$${esc(Number(acceptedPerDevice || 0).toFixed(2))}</div>
                ` : `
                  <div class="text-lg font-bold text-green-600">$${esc(Number(offer || 0).toFixed(2))}</div>
                `}
              </div>
            </div>
          `;
        }).join("");
        return `
          <div class="space-y-6">
            <div class="bg-white rounded-xl border border-slate-200 overflow-hidden shadow-sm">
              <div class="p-4 flex items-center justify-between border-b border-slate-100 bg-slate-50/50">
                <h3 class="font-semibold text-slate-700 flex items-center gap-2">
                  <i data-lucide="smartphone" class="text-slate-400" style="width:18px;height:18px"></i>
                  ${focused.isFocused ? `Device (1 of ${entries.length}) <span class="text-xs text-slate-400 font-bold">• ${esc(focused.label)}</span>` : `Devices (${entries.length})`}
                </h3>
                ${promoBadgeHTML(order)}
              </div>
              <div class="divide-y divide-slate-100">
                ${devices}
              </div>
            </div>
            <div class="bg-white rounded-xl border border-slate-200 overflow-hidden shadow-sm">
              <div class="p-4 border-b border-slate-100 bg-slate-50/50">
                <h3 class="font-semibold text-slate-700 flex items-center gap-2">
                  <i data-lucide="user" class="text-slate-400" style="width:18px;height:18px"></i>
                  Customer Info
                </h3>
              </div>
              <div class="p-5 grid grid-cols-1 sm:grid-cols-2 gap-5">
                <div>
                  <label class="text-xs font-medium text-slate-400 uppercase block mb-1">Full Name</label>
                  <div class="text-sm font-medium text-slate-900">${esc(order.shippingInfo?.fullName || "N/A")}</div>
                </div>
                <div>
                  <label class="text-xs font-medium text-slate-400 uppercase block mb-1">Phone Number</label>
                  <div class="text-sm font-medium text-slate-900">${esc(order.shippingInfo?.phone || "N/A")}</div>
                </div>
                <div>
                  <label class="text-xs font-medium text-slate-400 uppercase block mb-1">Email Address</label>
                  <div class="text-sm font-medium text-slate-900 flex items-center gap-2 break-all">
                    ${esc(order.shippingInfo?.email || "N/A")}
                    ${order.shippingInfo?.email ? `<a href="mailto:${esc(order.shippingInfo.email)}" class="text-indigo-600 hover:text-indigo-800"><i data-lucide="mail" style="width:14px;height:14px"></i></a>` : ""}
                  </div>
                </div>
                <div>
                  <label class="text-xs font-medium text-slate-400 uppercase block mb-1">Payout Method</label>
                  <div class="text-sm font-medium text-slate-900 capitalize">${esc(String(order.paymentMethod || "N/A").replace(/[_-]+/g, " "))}</div>
                  <div class="mt-2 bg-slate-50 border border-slate-200 rounded-lg p-3 space-y-2">
                    <div>
                      <label class="text-[11px] font-medium text-slate-400 uppercase block">Payout Info</label>
                    </div>
                    <div class="flex items-center justify-between text-sm">
                      <span class="text-slate-500">Quoted Payout</span>
                      <span class="font-semibold text-slate-900">$${esc(Number(getOrderPayoutTotal(order) || 0).toFixed(2))}</span>
                    </div>
                    <div class="flex items-center justify-between text-sm">
                      <span class="text-slate-500">Current Offer</span>
                      <span class="font-semibold text-emerald-700">$${esc(Number((order.reOffer?.newPrice ?? order.finalPayoutAmount ?? getOrderPayoutTotal(order)) || 0).toFixed(2))}</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        `;
      }
      function shippingHTML() {
        const tracking = getAnyTrackingNumber(order) || "N/A";
        const trackingHref = tracking && tracking !== "N/A"
          ? `https://tools.usps.com/go/TrackConfirmAction?tLabels=${encodeURIComponent(tracking)}`
          : "";
        return `
          <div class="space-y-6">
            <div class="bg-white rounded-xl border border-slate-200 overflow-hidden shadow-sm">
              <div class="p-4 border-b border-slate-100 bg-slate-50/50">
                <h3 class="font-semibold text-slate-700 flex items-center gap-2">
                  <i data-lucide="truck" class="text-slate-400" style="width:18px;height:18px"></i>
                  Tracking & Labels
                </h3>
              </div>
              <div class="p-5 space-y-4">
                <div>
                  <label class="text-xs font-medium text-slate-400 uppercase block mb-1">Tracking Number</label>
                  <div class="flex gap-2">
                    <input type="text" readonly value="${esc(tracking)}"
                      class="flex-1 bg-slate-50 border border-slate-300 rounded-md text-sm text-slate-600 focus:ring-0 px-3 py-2" />
                    ${trackingHref ? `
                      <a href="${trackingHref}" target="_blank" rel="noreferrer"
                        class="px-3 py-2 bg-white border border-slate-300 rounded-md text-slate-600 hover:bg-slate-50 flex items-center justify-center">
                        <i data-lucide="external-link" style="width:16px;height:16px"></i>
                      </a>
                    ` : ""}
                  </div>
                </div>
                <div class="flex flex-wrap gap-2">
                  <button data-action="generateLabel" class="px-3 py-2 rounded-lg text-sm font-semibold bg-indigo-600 text-white hover:bg-indigo-700">Generate Label</button>
                </div>
                <div class="pt-3 border-t border-slate-100">
                  <div class="text-xs font-semibold text-slate-400 uppercase mb-2">Void Labels</div>
                  <div class="flex flex-col gap-2">
                    ${(getLabelOptions(order).length ? getLabelOptions(order).map(opt => `
                      <label class="flex items-center gap-2 text-sm text-slate-700">
                        <input type="checkbox" class="h-4 w-4 rounded border-slate-300 text-rose-600 void-label-checkbox"
                          data-void-key="${esc(opt.key)}" data-void-id="${esc(opt.id)}" />
                        ${esc(opt.label)}
                      </label>
                    `).join("") : `<div class="text-sm text-slate-500">No voidable labels detected.</div>`)}
                    <button id="void-label-submit" class="mt-2 px-3 py-2 rounded-lg text-sm font-semibold bg-rose-50 text-rose-700 border border-rose-200 hover:bg-rose-100 ${getLabelOptions(order).length ? "" : "opacity-50 cursor-not-allowed"}" ${getLabelOptions(order).length ? "" : "disabled"}>
                      Void Selected Labels
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        `;
      }
      function qcHTML() {
        const deviceKey = focused.isFocused ? focused.deviceKey : buildOrderDeviceKey(order.id, 0);
        const qcForDevice = (order?.qcDataByDevice && deviceKey) ? order.qcDataByDevice[deviceKey] : null;
        const legacy = (!qcForDevice && String(deviceKey).endsWith("::0")) ? order.qcData : null;
        const qc = qcForDevice || legacy;
        const hasQcData = !!qc;
        return `
          <div class="space-y-6">
            <div class="bg-white rounded-xl border border-slate-200 overflow-hidden shadow-sm">
              <div class="p-4 border-b border-slate-100 bg-slate-50/50 flex justify-between items-center">
                <h3 class="font-semibold text-slate-700 flex items-center gap-2">
                  <i data-lucide="shield-check" class="text-slate-400" style="width:18px;height:18px"></i>
                  QC Status ${focused.isFocused ? `<span class="text-xs text-slate-400 font-bold">• ${esc(focused.label)}</span>` : ""}
                </h3>
                ${hasQcData ? `<span class="text-xs bg-emerald-100 text-emerald-800 px-2 py-1 rounded-full font-medium">Completed</span>` : ""}
              </div>
              <div class="p-5">
                ${!hasQcData ? `
                  <div class="text-center py-8">
                    <div class="h-12 w-12 bg-indigo-50 text-indigo-600 rounded-full flex items-center justify-center mx-auto mb-3">
                      <i data-lucide="search" style="width:24px;height:24px"></i>
                    </div>
                    <h4 class="text-slate-900 font-medium mb-1">Inspection Required</h4>
                    <p class="text-sm text-slate-500 mb-4">No quality control data has been recorded for this device yet.</p>
                  </div>
                ` : `
                  <div class="space-y-4">
                    <div class="grid grid-cols-2 gap-4">
                      <div class="p-3 bg-slate-50 rounded-lg border border-slate-200">
                        <span class="text-xs text-slate-400 uppercase block">Device Match</span>
                        <span class="text-sm font-bold ${qc.deviceMatch === "yes" ? "text-emerald-600" : "text-rose-600"}">
                          ${qc.deviceMatch === "yes" ? "Match" : "Mismatch"}
                        </span>
                      </div>
                      <div class="p-3 bg-slate-50 rounded-lg border border-slate-200">
                        <span class="text-xs text-slate-400 uppercase block">Functional</span>
                        <span class="text-sm font-bold ${qc.isFunctional === "yes" ? "text-emerald-600" : "text-rose-600"}">
                          ${qc.isFunctional === "yes" ? "Yes" : "No"}
                        </span>
                      </div>
                    </div>
                    ${qc.notes ? `
                      <div class="mt-4 pt-4 border-t border-slate-100">
                        <label class="text-xs font-medium text-slate-400 uppercase block mb-1">Inspector Notes</label>
                        <p class="text-sm text-slate-700 bg-amber-50 p-3 rounded-lg border border-amber-100">${esc(qc.notes)}</p>
                      </div>
                    ` : ""}
                  </div>
                `}
              </div>
            </div>
          </div>
        `;
      }
      function logsHTML() {
        const logs = Array.isArray(order.activityLog) ? order.activityLog.slice().reverse() : [];
        return `
          <div class="bg-white rounded-xl border border-slate-200 overflow-hidden shadow-sm">
            <div class="p-4 border-b border-slate-100 bg-slate-50/50">
              <h3 class="font-semibold text-slate-700 flex items-center gap-2">
                <i data-lucide="file-text" class="text-slate-400" style="width:18px;height:18px"></i>
                Activity History
              </h3>
            </div>
            <div class="p-5">
              ${logs.length ? `
                <ul class="space-y-6">
                  ${logs.map((log) => {
                    const t = String(log?.type || '').toLowerCase();
                    const palette = t.includes('error')
                      ? { border: '#fecdd3', dot: '#fda4af', text: '#9f1239', sub: '#be123c' }
                      : t.includes('status')
                        ? { border: '#c7d2fe', dot: '#a5b4fc', text: '#312e81', sub: '#4338ca' }
                        : t.includes('payment')
                          ? { border: '#bbf7d0', dot: '#86efac', text: '#14532d', sub: '#15803d' }
                          : t.includes('label')
                            ? { border: '#bfdbfe', dot: '#93c5fd', text: '#1e3a8a', sub: '#1d4ed8' }
                            : t.includes('email')
                              ? { border: '#fde68a', dot: '#fcd34d', text: '#92400e', sub: '#b45309' }
                              : { border: '#e2e8f0', dot: '#cbd5e1', text: '#0f172a', sub: '#475569' };
                    return `
                    <li class="relative pl-6 border-l-2 last:border-0 pb-1" style="border-color:${palette.border}">
                      <div class="absolute -left-[9px] top-0 h-4 w-4 rounded-full border-2 border-white ring-1" style="background:${palette.dot}; box-shadow: 0 0 0 1px ${palette.border}"></div>
                      <div class="flex flex-col">
                        <span class="text-sm font-medium" style="color:${palette.text}">${esc(log.message || "")}</span>
                        <span class="text-xs mt-0.5" style="color:${palette.sub}">${esc((log.type ? `[${log.type}] ` : '') + formatDate(log.at))}</span>
                      </div>
                    </li>
                  `;}).join("")}
                </ul>
              ` : `
                <p class="italic text-center py-4 text-slate-500 text-sm">No activity recorded yet.</p>
              `}
            </div>
          </div>
        `;
      }
      const tabContent =
        state.drawerTab === "overview" ? overviewHTML()
        : state.drawerTab === "shipping" ? shippingHTML()
        : state.drawerTab === "qc" ? qcHTML()
        : logsHTML();
      return `
        <div class="fixed inset-0 z-[1002] flex justify-end">
          <div class="absolute inset-0 bg-slate-900/30 backdrop-blur-sm transition-opacity" data-close-drawer="1"></div>
          <div class="relative w-full max-w-2xl bg-white h-full shadow-2xl flex flex-col">
            <div class="relative bg-white z-[1009] px-6 py-4 flex justify-between items-start">
              <div class="relative">
                <div class="flex items-center gap-3 mb-1">
                  <h2 class="text-2xl font-bold text-slate-900">#${esc(order.id)}</h2>
                  <div class="relative z-[1300]" id="modalStatusWrapper">
                    <button id="modalStatusBtn" class="inline-flex items-center gap-2 px-2.5 py-1 rounded-full text-xs font-semibold border ${getStatusClass(order.status)} hover:opacity-90">
                      ${esc(formatStatusLabel(order.status))}
                      <i data-lucide="chevron-down" style="width:14px;height:14px"></i>
                    </button>
                    ${renderStatusDropdown(order)}
                  </div>
                </div>
                <p class="text-sm text-slate-500 flex items-center gap-2">
                  <i data-lucide="clock" style="width:14px;height:14px"></i>
                  Created ${esc(formatDate(order.createdAt))} (${esc(getOrderAge(order.createdAt))})
                </p>
              </div>
              <button class="p-2 hover:bg-slate-100 rounded-full text-slate-500 transition-colors" data-close-drawer="1">
                <i data-lucide="x" style="width:24px;height:24px"></i>
              </button>
            </div>
            ${workflowStepperHTML(order)}
            <div class="px-6 border-b border-slate-200 bg-slate-50/50 flex space-x-6 overflow-x-auto scrollbar-hide">
              ${tabs.map(t => `
                <button data-drawer-tab="${t.id}"
                  class="flex items-center gap-2 py-4 text-sm font-medium border-b-2 transition-colors whitespace-nowrap ${
                    state.drawerTab === t.id
                      ? "border-indigo-600 text-indigo-600"
                      : "border-transparent text-slate-500 hover:text-slate-700 hover:border-slate-300"
                  }">
                  <i data-lucide="${t.icon}" style="width:16px;height:16px"></i>
                  ${esc(t.label)}
                </button>
              `).join("")}
            </div>
            <div class="p-6 space-y-6 flex-1 overflow-y-auto bg-slate-50/30">
              ${tabContent}
            </div>
            <div class="border-t border-slate-200 p-6 bg-white z-10">
              ${renderDrawerFooter(order)}
            </div>
          </div>
        </div>
      `;
    }
    function renderDrawerFooter(order) {
        const status = normalizeStatusKey(order.status || "order_pending");
        const hasQc = !!(order.qcData || (order.qcDataByDevice && Object.keys(order.qcDataByDevice).length));
        const groups = {
            primary: [],
            shipping: [],
            postReceive: [],
            tracking: [],
            admin: []
        };
        // Helpers
        const hasLabels = !!(getAnyTrackingNumber(order) || getShipEngineLabelEntries(order).length);
        const isKitReq = order.shippingPreference === "Shipping Kit Requested";
        const isEmailReq = order.shippingPreference === "Email Label Requested";

        // --- Status Logic ---
        if (["order_pending", "kit_needs_printing", "needs_printing"].includes(status)) {
            if (!hasLabels) groups.primary.push({ label: "Generate USPS Label", action: "generateLabel", class: "bg-indigo-600 text-white" });
            groups.primary.push({ label: "Order Manually Fulfilled", action: "manualFulfill", class: "bg-slate-100 text-slate-800" });
        }
        else if (status === "shipping_kit_requested") {
            // ALWAYS show generate label
            groups.primary.push({ label: "Generate USPS Label", action: "generateLabel", class: "bg-indigo-600 text-white" });
            groups.primary.push({ label: "Order Manually Fulfilled", action: "manualFulfill", class: "bg-slate-100 text-slate-800" });
        }
        else if (["kit_on_the_way_to_us", "kit_delivered", "phone_on_the_way", "delivered_to_us"].includes(status)) {
            groups.shipping.push({ label: "Mark as Received", action: "markReceived", class: "bg-white border-slate-200 text-slate-700" });
        }
        else if (status === "label_generated") {
            if (isKitReq) groups.shipping.push({ label: "Mark Kit Sent", action: "markKitSent", class: "bg-white border-slate-200 text-slate-700" });
            groups.shipping.push({ label: "Mark as Received", action: "markReceived", class: "bg-white border-slate-200 text-slate-700" });
        }
        else if (["received", "imei_checked"].includes(status)) {
            groups.postReceive.push({ label: hasQc ? "Edit QC Checklist" : "Start QC Checklist", id: "openQcBtn", class: "bg-indigo-50 text-indigo-700 border-indigo-100" });
            groups.postReceive.push({ label: "Mark Completed", action: "markCompleted", class: "bg-emerald-600 text-white" });
            groups.postReceive.push({ label: "Propose Re-offer", action: "reOffer", class: "bg-purple-100 text-purple-700" });
        }
        else if (status === "emailed") {
            groups.postReceive.push({ label: hasQc ? "Edit QC Checklist" : "Start QC Checklist", id: "openQcBtn", class: "bg-indigo-50 text-indigo-700 border-indigo-100" });
            groups.postReceive.push({ label: "Propose Re-offer", action: "reOffer", class: "bg-purple-100 text-purple-700" });
            groups.postReceive.push({ label: "Finalize 75% Reduced Payout", action: "autoRequote", class: "bg-slate-100 text-slate-800" });
            groups.postReceive.push({ label: "Generate Return Label", action: "sendReturnLabel", class: "bg-white border-slate-200" });
        }
        else if (status === "re-offered-pending") {
             groups.primary.push({ label: "Re-offer Pending (View Info)", type: "info", class: "bg-slate-100 text-slate-500 cursor-default" });
        }
        else if (status === "re-offered-accepted") {
            if (order.paymentMethod === 'zelle') {
                 groups.primary.push({ label: "Mark Paid", action: "markCompleted", class: "bg-emerald-600 text-white" });
            } else {
                 groups.primary.push({ label: "Pay Now", action: "payNow", class: "bg-emerald-600 text-white" });
            }
        }
        else if (status === "re-offered-declined") {
            groups.primary.push({ label: "Send Return Label", action: "sendReturnLabel", class: "bg-white border-slate-200" });
        }
        else if (["requote_accepted", "completed"].includes(status)) {
            groups.postReceive.push({ label: "Send Review Request", action: "sendReviewRequest", class: "bg-white border-slate-200" });
        }

        // --- Independent ---
        // Auto requote button
        // Logic not strictly defined, assuming if not completed and maybe received? 
        // Spec says "Post-Receive > Status Independent". I'll add if status is received/imei_checked/emailed(balance)
        if (["received", "imei_checked"].includes(status)) {
             groups.postReceive.push({ label: "Finalize 75% Reduced Payout", action: "autoRequote", class: "bg-slate-100 text-slate-800" });
        }

        // Tracking
        // Print docs (mock check for URL)
        if (order.outboundLabelUrl && order.inboundLabelUrl && ["label_generated", "shipping_kit_requested", "kit_needs_printing", "needs_printing", "kit_sent"].includes(status)) {
             groups.tracking.unshift({ label: "Print Kit Docs", action: "printDocs", class: "bg-white border-slate-200" });
        }
        groups.tracking.push({ label: "Print Packing Slip", action: "printPacking", class: "bg-white border-slate-200" });

        // Admin
        if (status !== 'cancelled') {
             groups.admin.push({ label: "Cancel Order", action: "cancelOrder", class: "text-rose-600 hover:bg-rose-50" });
        }
        groups.admin.push({ label: "Delete Order", action: "deleteOrder", class: "text-rose-600 hover:bg-rose-50" });

        // --- Render ---
        const renderBtn = (b) => `
            <button ${b.id ? `id="${b.id}"` : ""} ${b.action ? `data-action="${b.action}"` : ""} class="px-4 py-2 rounded-xl text-xs sm:text-sm font-bold shadow-sm transition-all ${b.class || "bg-white border-slate-200 text-slate-700"}">
                ${esc(b.label)}
            </button>
        `;

        let html = '<div class="space-y-4">';

        if (groups.primary.length) {
             html += `<div class="grid grid-cols-1 sm:grid-cols-2 gap-2">${groups.primary.map(renderBtn).join("")}</div>`;
        }
        if (groups.shipping.length) {
             html += `<div class="p-3 bg-blue-50/50 rounded-xl border border-blue-100"><div class="text-[10px] font-bold text-blue-400 uppercase tracking-wider mb-2">Shipping & Intake</div><div class="grid grid-cols-1 sm:grid-cols-2 gap-2">${groups.shipping.map(renderBtn).join("")}</div></div>`;
        }
        if (groups.postReceive.length) {
             html += `<div class="p-3 bg-indigo-50/50 rounded-xl border border-indigo-100"><div class="text-[10px] font-bold text-indigo-400 uppercase tracking-wider mb-2">Post-Receive</div><div class="grid grid-cols-1 sm:grid-cols-2 gap-2">${groups.postReceive.map(renderBtn).join("")}</div></div>`;
        }
        if (groups.tracking.length) {
             html += `<div class="grid grid-cols-1 sm:grid-cols-2 gap-2">${groups.tracking.map(renderBtn).join("")}</div>`;
        }
        if (groups.admin.length) {
             html += `<div class="pt-3 border-t border-slate-100 flex flex-wrap gap-2 items-center">
                ${groups.admin.map(b => `<button data-action="${b.action}" class="px-3 py-2 rounded-lg text-xs font-semibold border transition-colors ${b.class?.includes("rose") ? "border-rose-200 bg-rose-50 text-rose-700 hover:bg-rose-100" : "border-slate-200 bg-white text-slate-700 hover:bg-slate-50"}">${b.label}</button>`).join("")}
             </div>`;
        }
        html += '</div>';
        return html;
    }
    // ----------------------------
    // QC MODAL (your existing)
    // ----------------------------
    function renderQcModal(order) {
      if (!state.qcOpen) return "";
      const entries = getOrderDeviceEntries(order);
      const modalDeviceKey = state.qcDeviceKey || state.selectedDeviceKey || buildOrderDeviceKey(order.id, 0);
      const parsed = parseOrderDeviceKey(modalDeviceKey);
      const entry = entries.find(e => e.deviceIndex === parsed.deviceIndex) || entries[0] || { deviceIndex: 0, item: order, qtyIndex: 0 };
      const currentItem = entry.item || order;
      const qcForDevice = order?.qcDataByDevice?.[modalDeviceKey] || null;
      const legacy = (!qcForDevice && parsed.deviceIndex === 0) ? (order.qcData || null) : null;
      const existing = qcForDevice || legacy;
      if (!state.qcData || state.qcDeviceKey !== modalDeviceKey) {
        state.qcDeviceKey = modalDeviceKey;
        state.qcData = {
          deviceMatch: "yes",
          deviceName: currentItem.device || order.device || "",
          storage: currentItem.storage || order.storage || "",
          imei: currentItem.imei || order.imei || "",
          condition: currentItem.condition || order.condition || "good",
          carrier: currentItem.carrier || currentItem.lock || order.carrier || order.lock || "unlocked",
          actualBrand: (currentItem.brand || order.brand || '').toLowerCase(),
          actualModelId: currentItem.modelId || currentItem.model || order.modelId || order.model || "",
          actualStorage: currentItem.storage || order.storage || "",
          storageMatch: "yes",
          isFunctional: "yes",
          hasDamage: "no",
          hasCracks: "no",
          isLocked: "no",
          hasFmi: "no",
          hasBalance: "no",
          notes: "",
          ...(existing || {})
        };
      }
      const steps = [
        { title: "Device Verification" },
        { title: "Condition & Grade" },
        { title: "Functionality & Locks" }
      ];
      const pct = Math.round((state.qcStep / steps.length) * 100);
      function step1() {
        return `
          <div class="space-y-4">
            <img src="https://images.unsplash.com/photo-1511707171634-5f897ff02aa9?auto=format&fit=crop&w=900&q=60" alt="Phone inspection" class="w-full h-32 object-cover rounded-xl border border-slate-200" loading="lazy" />
            <p class="text-sm text-slate-600">Customer declared: <strong>${esc(currentItem.device)} (${esc(currentItem.storage)})</strong></p>
            <div>
              <label class="block text-sm font-medium text-slate-700 mb-2">Is this the proper device (model)?</label>
              <div class="flex gap-4">
                <label class="flex items-center gap-2 border p-3 rounded-lg flex-1 cursor-pointer hover:bg-slate-50">
                  <input type="radio" name="deviceMatch" value="yes" ${state.qcData.deviceMatch === "yes" ? "checked" : ""} class="text-indigo-600" />
                  <span class="text-sm font-medium">Yes</span>
                </label>
                <label class="flex items-center gap-2 border p-3 rounded-lg flex-1 cursor-pointer hover:bg-slate-50">
                  <input type="radio" name="deviceMatch" value="no" ${state.qcData.deviceMatch === "no" ? "checked" : ""} class="text-indigo-600" />
                  <span class="text-sm font-medium">No</span>
                </label>
              </div>
            </div>
            ${state.qcData.deviceMatch === "no" ? `
              <div class="bg-slate-50 p-4 rounded-lg border border-slate-200 space-y-3">
                <label class="block text-xs font-semibold uppercase text-slate-500">Actual Device</label>
                <div>
                  <label class="block text-xs font-semibold text-slate-500 mb-1">Brand</label>
                  <select id="qcActualBrand" class="w-full border border-slate-300 rounded-md text-sm py-2.5 focus:ring-indigo-500 focus:border-indigo-500">
                    ${[['iphone','Apple iPhone'],['samsung','Samsung'],['google','Google Pixel']].map(([v,l]) => `<option value="${v}" ${state.qcData.actualBrand === v ? 'selected' : ''}>${l}</option>`).join('')}
                  </select>
                </div>
                <div>
                  <label class="block text-xs font-semibold text-slate-500 mb-1">Model</label>
                  <select id="qcActualModelId" class="w-full border border-slate-300 rounded-md text-sm py-2.5 focus:ring-indigo-500 focus:border-indigo-500">
                    ${(state.qcModelCache?.[state.qcData.actualBrand] || []).map(m => `<option value="${esc(m.id)}" ${state.qcData.actualModelId === m.id ? 'selected' : ''}>${esc(m.name || m.id)}</option>`).join('') || '<option value="">Select model</option>'}
                  </select>
                </div>
              </div>
            ` : ""}
            <div>
              <label class="block text-sm font-medium text-slate-700 mb-2">Is the storage / gigabyte amount correct?</label>
              <div class="flex gap-4">
                <label class="flex items-center gap-2 border p-3 rounded-lg flex-1 cursor-pointer hover:bg-slate-50">
                  <input type="radio" name="storageMatch" value="yes" ${state.qcData.storageMatch === "yes" ? "checked" : ""} class="text-indigo-600" />
                  <span class="text-sm font-medium">Yes</span>
                </label>
                <label class="flex items-center gap-2 border p-3 rounded-lg flex-1 cursor-pointer hover:bg-slate-50">
                  <input type="radio" name="storageMatch" value="no" ${state.qcData.storageMatch === "no" ? "checked" : ""} class="text-indigo-600" />
                  <span class="text-sm font-medium">No</span>
                </label>
              </div>
              ${state.qcData.storageMatch === "no" ? `
                <div class="mt-3">
                  <label class="block text-xs font-semibold text-slate-500 mb-1">Actual Storage / GB</label>
                  <select id="qcActualStorage" class="w-full border border-slate-300 rounded-md text-sm py-2.5 focus:ring-indigo-500 focus:border-indigo-500">
                    ${(state.qcStorageCache?.[`${state.qcData.actualBrand}::${state.qcData.actualModelId}`] || []).map(v => `<option value="${esc(v)}" ${state.qcData.actualStorage === v ? 'selected' : ''}>${esc(v)}</option>`).join('') || '<option value="">Select storage</option>'}
                  </select>
                </div>
              ` : ""}
            </div>
            <div>
              <label class="block text-sm font-medium text-slate-700 mb-2">Carrier / lock status</label>
              <select id="qcCarrier" class="w-full border border-slate-300 rounded-md text-sm py-2.5 focus:ring-indigo-500 focus:border-indigo-500">
                ${["unlocked","att","tmobile","verizon","other"].map(v => `<option value="${v}" ${state.qcData.carrier === v ? "selected" : ""}>${v === "unlocked" ? "Unlocked" : v === "att" ? "AT&T" : v === "tmobile" ? "T-Mobile" : v === "verizon" ? "Verizon" : "Other"}</option>`).join("")}
              </select>
            </div>
          </div>
        `;
      }
      function step2() {
        return `
          <div class="space-y-4">
            <img src="https://images.unsplash.com/photo-1526570207772-784d36084510?auto=format&fit=crop&w=900&q=60" alt="Cracked phone screen" class="w-full h-32 object-cover rounded-xl border border-slate-200" loading="lazy" />
            <div>
              <label class="block text-sm font-medium text-slate-700 mb-2">Quality / condition grade</label>
              <select id="qcCondition" class="w-full border border-slate-300 rounded-md text-sm py-2.5 focus:ring-indigo-500 focus:border-indigo-500">
                ${["flawless","good","fair","broken"].map(v => `
                  <option value="${v}" ${state.qcData.condition === v ? "selected" : ""}>
                    ${v === "flawless" ? "Flawless" : v === "good" ? "Good" : v === "fair" ? "Fair" : "Broken"}
                  </option>
                `).join("")}
              </select>
            </div>
            <label class="flex items-center justify-between p-4 border rounded-lg hover:bg-slate-50 cursor-pointer">
              <span class="text-sm text-slate-700">Visible damage beyond normal wear?</span>
              <input id="qcHasDamage" type="checkbox" ${state.qcData.hasDamage === "yes" ? "checked" : ""} class="h-5 w-5 accent-rose-600" />
            </label>
          </div>
        `;
      }
      function step3() {
        const locked = state.qcData.isLocked === "yes";
        const fmi = state.qcData.hasFmi === "yes";
        const balance = state.qcData.hasBalance === "yes";
        return `
          <div class="space-y-4">
            <img src="https://images.unsplash.com/photo-1563013544-824ae1b704d3?auto=format&fit=crop&w=900&q=60" alt="Phone lock security" class="w-full h-32 object-cover rounded-xl border border-slate-200" loading="lazy" />
            <div>
              <label class="block text-sm font-medium text-slate-700 mb-2">Functionality</label>
              <div class="grid grid-cols-2 gap-3">
                <label class="flex items-center justify-center p-3 border rounded-lg cursor-pointer ${state.qcData.isFunctional === "yes" ? "bg-green-50 border-green-200 text-green-700 ring-1 ring-green-500" : "hover:bg-slate-50"}">
                  <input type="radio" class="sr-only" name="isFunctional" value="yes" ${state.qcData.isFunctional === "yes" ? "checked" : ""} />
                  <span class="text-sm font-bold">Fully Functional</span>
                </label>
                <label class="flex items-center justify-center p-3 border rounded-lg cursor-pointer ${state.qcData.isFunctional === "no" ? "bg-red-50 border-red-200 text-red-700 ring-1 ring-red-500" : "hover:bg-slate-50"}">
                  <input type="radio" class="sr-only" name="isFunctional" value="no" ${state.qcData.isFunctional === "no" ? "checked" : ""} />
                  <span class="text-sm font-bold">Not Functional</span>
                </label>
              </div>
            </div>
            <label class="flex items-center justify-between p-4 border rounded-lg hover:bg-slate-50 cursor-pointer">
              <span class="text-sm font-medium text-slate-900">Cracked screen or back?</span>
              <input id="qcHasCracks" type="checkbox" ${state.qcData.hasCracks === "yes" ? "checked" : ""} class="h-5 w-5 accent-rose-600" />
            </label>
            <label class="flex items-center justify-between p-4 border rounded-lg hover:bg-slate-50 cursor-pointer">
              <div class="flex items-center gap-3">
                <i data-lucide="shield-check" class="${locked ? "text-rose-500" : "text-slate-400"}" style="width:20px;height:20px"></i>
                <span class="text-sm font-medium text-slate-900">iCloud / Google / carrier lock active?</span>
              </div>
              <input id="qcIsLocked" type="checkbox" ${locked ? "checked" : ""} class="h-5 w-5 accent-rose-600" />
            </label>
            <label class="flex items-center justify-between p-4 border rounded-lg hover:bg-slate-50 cursor-pointer">
              <div class="flex items-center gap-3">
                <i data-lucide="key-round" class="${fmi ? "text-amber-500" : "text-slate-400"}" style="width:20px;height:20px"></i>
                <span class="text-sm font-medium text-slate-900">FMI / Find My iPhone active?</span>
              </div>
              <input id="qcHasFmi" type="checkbox" ${fmi ? "checked" : ""} class="h-5 w-5 accent-amber-500" />
            </label>
            <label class="flex items-center justify-between p-4 border rounded-lg hover:bg-slate-50 cursor-pointer">
              <div class="flex items-center gap-3">
                <i data-lucide="dollar-sign" class="${balance ? "text-amber-500" : "text-slate-400"}" style="width:20px;height:20px"></i>
                <span class="text-sm font-medium text-slate-900">Finance / balance owed?</span>
              </div>
              <input id="qcHasBalance" type="checkbox" ${balance ? "checked" : ""} class="h-5 w-5 accent-amber-500" />
            </label>
            <div>
              <label class="block text-xs font-semibold uppercase text-slate-500 mb-1">Device IMEI (Optional)</label>
              <input id="qcImei" type="text" value="${esc(state.qcData.imei)}" inputmode="numeric" maxlength="15"
                class="w-full border border-slate-300 rounded-md text-sm focus:ring-indigo-500 focus:border-indigo-500 font-mono px-3 py-2"
                placeholder="Enter 15-digit IMEI" />
            </div>
            <div>
              <label class="block text-xs font-semibold uppercase text-slate-500 mb-1">Internal Notes</label>
              <textarea id="qcNotes"
                class="w-full border border-slate-300 rounded-md text-sm focus:ring-indigo-500 focus:border-indigo-500 h-20 px-3 py-2"
                placeholder="Any additional details...">${esc(state.qcData.notes)}</textarea>
            </div>
          </div>
        `;
      }
      const content = state.qcStep === 1 ? step1() : state.qcStep === 2 ? step2() : step3();
      return `
        <div class="fixed inset-0 z-[1300] flex items-center justify-center p-4 bg-slate-900/50 backdrop-blur-sm" style="z-index:5000;">
          <div class="bg-white rounded-2xl shadow-xl w-full max-w-lg max-h-[88vh] sm:max-h-[90vh] overflow-hidden border border-slate-200 flex flex-col">
            <div class="bg-slate-50 px-6 py-4 border-b border-slate-100 flex justify-between items-center">
              <div>
                <h3 class="text-lg font-bold text-slate-900">QC Intake</h3>
                <p class="text-xs text-slate-500">Order ${esc(order.id)}</p>
              </div>
              <button id="qcCloseBtn" class="text-slate-400 hover:text-slate-600 transition-colors">
                <i data-lucide="x" style="width:20px;height:20px"></i>
              </button>
            </div>
            <div id="qcModalBody" class="px-6 py-4 overflow-y-auto flex-1 min-h-0">
              <div class="mb-6">
                <div class="flex items-center justify-between text-xs font-semibold text-slate-400 uppercase tracking-wide mb-2">
                  <span>Step ${state.qcStep} of ${steps.length}</span>
                  <span>${pct}%</span>
                </div>
                <div class="h-1.5 w-full bg-slate-100 rounded-full overflow-hidden">
                  <div class="h-full bg-indigo-600 transition-all duration-300 ease-out" style="width:${pct}%"></div>
                </div>
              </div>
              <h4 class="text-lg font-bold text-slate-900 mb-3">${esc(steps[state.qcStep-1].title)}</h4>
              ${content}
            </div>
            <div class="px-6 py-4 bg-slate-50 border-t border-slate-100 flex justify-between items-center">
              <button id="qcBackBtn"
                class="px-4 py-2 text-sm font-medium text-slate-600 hover:text-slate-900 hover:bg-white rounded-lg border border-transparent hover:border-slate-200 transition-all">
                ${state.qcStep === 1 ? "Cancel" : "Back"}
              </button>
              ${state.qcStep < steps.length ? `
                <button id="qcNextBtn"
                  class="px-6 py-2 text-sm font-bold text-white bg-indigo-600 hover:bg-indigo-700 rounded-lg shadow-sm shadow-indigo-200 transition-all">
                  Next Step
                </button>
              ` : `
                <button id="qcFinishBtn"
                  class="px-6 py-2 text-sm font-bold text-white bg-emerald-600 hover:bg-emerald-700 rounded-lg shadow-sm shadow-emerald-200 transition-all flex items-center gap-2">
                  <i data-lucide="save" style="width:16px;height:16px"></i> Finish QC
                </button>
              `}
            </div>
          </div>
        </div>
      `;
    }
    function renderReofferModal(order) {
      if (!state.reofferOpen || !state.reofferData || !order) return "";
      const d = state.reofferData;
      return `
        <div class="fixed inset-0 z-[5100] flex items-center justify-center p-4 bg-slate-900/55 backdrop-blur-sm" style="z-index:99999;">
          <div class="bg-white rounded-2xl shadow-xl w-full max-w-xl max-h-[90vh] overflow-hidden border border-slate-200 flex flex-col">
            <div class="bg-purple-50 px-6 py-4 border-b border-purple-100 flex justify-between items-center">
              <div>
                <h3 class="text-lg font-bold text-slate-900">Propose Re-offer</h3>
                <p class="text-xs text-slate-500">Order ${esc(order.id)} • Prefilled from QC</p>
              </div>
              <button id="reofferCloseBtn" class="text-slate-400 hover:text-slate-600"><i data-lucide="x" style="width:20px;height:20px"></i></button>
            </div>
            <div id="reofferModalBody" class="p-6 space-y-4 overflow-y-auto flex-1 min-h-0">
              <div>
                <label class="block text-xs font-semibold uppercase text-slate-500 mb-1">Updated Price ($)</label>
                <input id="reofferPrice" type="number" min="0" step="0.01" value="${esc(d.newPrice)}" class="w-full border border-slate-300 rounded-md px-3 py-2 text-sm" />
              </div>
              <div class="grid grid-cols-2 gap-3">
                <div>
                  <label class="block text-xs font-semibold uppercase text-slate-500 mb-1">Carrier</label>
                  <input id="reofferCarrier" type="text" value="${esc(d.carrier)}" class="w-full border border-slate-300 rounded-md px-3 py-2 text-sm" />
                </div>
                <div>
                  <label class="block text-xs font-semibold uppercase text-slate-500 mb-1">Condition</label>
                  <input id="reofferCondition" type="text" value="${esc(d.condition)}" class="w-full border border-slate-300 rounded-md px-3 py-2 text-sm" />
                </div>
              </div>
              <div>
                <label class="block text-xs font-semibold uppercase text-slate-500 mb-1">Reason(s)</label>
                <textarea id="reofferReasons" class="w-full border border-slate-300 rounded-md px-3 py-2 text-sm h-20">${esc(d.reasons)}</textarea>
              </div>
              <div>
                <label class="block text-xs font-semibold uppercase text-slate-500 mb-1">Comments</label>
                <textarea id="reofferComments" class="w-full border border-slate-300 rounded-md px-3 py-2 text-sm h-20">${esc(d.comments)}</textarea>
              </div>
            </div>
            <div class="px-6 py-4 bg-slate-50 border-t border-slate-100 flex justify-end gap-2">
              <button id="reofferCancelBtn" class="px-4 py-2 rounded-lg border border-slate-200 bg-white text-sm font-semibold">Cancel</button>
              <button id="reofferSubmitBtn" class="px-4 py-2 rounded-lg bg-purple-600 hover:bg-purple-700 text-white text-sm font-semibold">Send Re-offer</button>
            </div>
          </div>
        </div>
      `;
    }

    // ----------------------------
    // ORDER TEXT IMPORT MODAL (placeholder; spec says implementation exists elsewhere)
    // ----------------------------
    function renderOrderTextImportModal() {
      if (!state.orderTextImportOpen) return "";
      return `
        <div class="fixed inset-0 z-50 flex items-center justify-center p-4 bg-slate-900/50 backdrop-blur-sm">
          <div class="bg-white rounded-2xl shadow-xl w-full max-w-2xl max-h-[90vh] overflow-hidden border border-slate-200 flex flex-col">
            <div class="bg-slate-50 px-6 py-4 border-b border-slate-100 flex justify-between items-center">
              <div>
                <h3 class="text-lg font-bold text-slate-900">Paste Order From Text</h3>
                <p class="text-xs text-slate-500">This is wired + ready — paste parsing/submit logic can be dropped in.</p>
              </div>
              <button id="orderTextImportCloseBtn" class="text-slate-400 hover:text-slate-600 transition-colors">
                <i data-lucide="x" style="width:20px;height:20px"></i>
              </button>
            </div>
            <div id="orderTextImportBody" class="px-6 py-6 space-y-3 overflow-y-auto flex-1 min-h-0">
              <textarea id="orderTextImportInput" class="w-full h-52 border border-slate-300 rounded-xl p-3 text-sm font-mono"
                placeholder="Paste the raw order text here…"></textarea>
              <div class="flex justify-end gap-2">
                <button id="orderTextImportCancelBtn" class="px-4 py-2 rounded-lg border border-slate-200 bg-white hover:bg-slate-50 font-semibold text-sm">Cancel</button>
                <button id="orderTextImportSubmitBtn" class="px-4 py-2 rounded-lg bg-indigo-600 hover:bg-indigo-700 text-white font-semibold text-sm">Submit</button>
              </div>
            </div>
          </div>
        </div>
      `;
    }
    // ----------------------------
    // MAIN RENDER
    // ----------------------------
    function renderApp() {
      return `
        <div class="min-h-screen bg-slate-50 font-sans text-slate-900 flex">
          ${renderSidebar()}
          <div class="flex-1 flex flex-col transition-all duration-300">
            ${renderTopbar()}
            ${state.activeTab === "orders" ? renderOrdersPage() : `
              <main class="flex-1 p-8">
                <div class="bg-white border border-slate-200 rounded-xl p-6">
                  <div class="text-sm text-slate-600">Tab <b>${esc(state.activeTab)}</b> is a placeholder in this no-build version.</div>
                </div>
              </main>
            `}
          </div>
          ${getSelectedOrder() ? renderDrawer(getSelectedOrder()) : ""}
          ${getSelectedOrder() ? renderQcModal(getSelectedOrder()) : ""}
          ${getSelectedOrder() ? renderReofferModal(getSelectedOrder()) : ""}
          ${renderOrderTextImportModal()}
        </div>
      `;
    }
    function hasBlockingOverlayOpen() {
      return !!(getSelectedOrder() || state.qcOpen || state.reofferOpen || state.orderTextImportOpen);
    }
    function restoreModalScrollPositions() {
      const qcBody = document.getElementById("qcModalBody");
      if (qcBody) {
        qcBody.scrollTop = Number(state.modalScrollTop?.qc || 0);
        qcBody.addEventListener("scroll", () => { state.modalScrollTop.qc = qcBody.scrollTop; }, { passive: true });
      }
      const reofferBody = document.getElementById("reofferModalBody");
      if (reofferBody) {
        reofferBody.scrollTop = Number(state.modalScrollTop?.reoffer || 0);
        reofferBody.addEventListener("scroll", () => { state.modalScrollTop.reoffer = reofferBody.scrollTop; }, { passive: true });
      }
      const importBody = document.getElementById("orderTextImportBody");
      if (importBody) {
        importBody.scrollTop = Number(state.modalScrollTop?.import || 0);
        importBody.addEventListener("scroll", () => { state.modalScrollTop.import = importBody.scrollTop; }, { passive: true });
      }
    }
    function syncBodyScrollLock() {
      const lock = hasBlockingOverlayOpen();
      document.documentElement.style.overflow = lock ? "hidden" : "";
      document.body.style.overflow = lock ? "hidden" : "";
    }

    function render() {
      if (state.authLoading) {
        $root.innerHTML = `
          <div class="h-screen w-full flex items-center justify-center bg-slate-50">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600"></div>
          </div>
        `;
        syncBodyScrollLock();
        return;
      }
      if (!state.user) {
        $root.innerHTML = renderLogin();
        lucide.createIcons();
        bindLogin();
        syncBodyScrollLock();
        return;
      }
      $root.innerHTML = renderApp();
      lucide.createIcons();
      bindAppEvents();
      restoreModalScrollPositions();
      // after DOM is present
      refreshPromoFilterOptions();
      // mirror promo options into mobile select
      const desk = document.getElementById("promoFilterSelect");
      const mob = document.getElementById("promoFilterSelectMobile");
      if (desk && mob) {
        mob.innerHTML = desk.innerHTML;
        mob.value = desk.value;
      }
      updateSelectAllCheckboxUI();
      syncBodyScrollLock();
    }
    // ----------------------------
    // EVENTS
    // ----------------------------
    function bindAppEvents() {
      if (!state.viewDelegationBound) {
        document.addEventListener("click", (event) => {
          const orderBtn = event.target.closest("[data-view-order]");
          if (orderBtn) {
            event.preventDefault();
            event.stopPropagation();
            const orderId = orderBtn.getAttribute("data-view-order");
            if (!orderId) return;
            state.selectedOrderId = orderId;
            state.selectedOrderSnapshot = state.allOrders.find(o => o.id === orderId) || state.selectedOrderSnapshot || null;
            state.selectedDeviceKey = null;
            state.qcDeviceKey = null;
            state.drawerTab = "overview";
            state.statusDropdownOpen = false;
            state.qcOpen = false;
            state.qcStep = 1;
            state.qcData = null;
            state.reofferOpen = false;
            state.reofferData = null;
            render();
            return;
          }

          const deviceBtn = event.target.closest("[data-view-device]");
          if (deviceBtn) {
            event.preventDefault();
            event.stopPropagation();
            const deviceKey = deviceBtn.getAttribute("data-view-device");
            if (!deviceKey) return;
            const parsed = parseOrderDeviceKey(deviceKey);
            state.selectedOrderId = parsed.orderId;
            state.selectedOrderSnapshot = state.allOrders.find(o => o.id === parsed.orderId) || state.selectedOrderSnapshot || null;
            state.selectedDeviceKey = deviceKey;
            state.qcDeviceKey = deviceKey;
            state.drawerTab = "qc";
            state.statusDropdownOpen = false;
            state.qcOpen = false;
            state.qcStep = 1;
            state.qcData = null;
            state.reofferOpen = false;
            state.reofferData = null;
            render();
          }
        });
        state.viewDelegationBound = true;
      }

      // Logout
      const logoutBtn = document.getElementById("logoutBtn");
      if (logoutBtn) logoutBtn.addEventListener("click", () => signOut(auth));
      // Search inputs
      const search = document.getElementById("searchInput");
      if (search) {
        search.addEventListener("input", () => applySearchTerm(search.value));
      }
      const mobileSearch = document.getElementById("mobileSearchInput");
      if (mobileSearch) {
        mobileSearch.addEventListener("input", () => applySearchTerm(mobileSearch.value));
      }
      // Status breakdown clicks + keyboard enter/space
      document.querySelectorAll("[data-status-tab]").forEach(btn => {
        const go = () => {
          const key = btn.getAttribute("data-status-tab");
          filterAndRenderOrders(key, state.currentSearchTerm, { preservePage: false });
        };
        btn.addEventListener("click", go);
        btn.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") { e.preventDefault(); go(); }
        });
      });
      // Promo filter
      const promoSel = document.getElementById("promoFilterSelect");
      if (promoSel) {
        promoSel.value = state.currentPromoFilter || PROMO_FILTER.ALL;
        promoSel.addEventListener("change", () => {
          state.currentPromoFilter = promoSel.value;
          filterAndRenderOrders(state.currentActiveStatus, state.currentSearchTerm, { preservePage: true });
        });
      }
      const promoSelMobile = document.getElementById("promoFilterSelectMobile");
      if (promoSelMobile) {
        promoSelMobile.value = state.currentPromoFilter || PROMO_FILTER.ALL;
        promoSelMobile.addEventListener("change", () => {
          state.currentPromoFilter = promoSelMobile.value;
          filterAndRenderOrders(state.currentActiveStatus, state.currentSearchTerm, { preservePage: true });
        });
      }
      // Density toggle
      const density = document.getElementById("compactDensityToggle");
      if (density) {
        density.checked = !!state.compactDensity;
        density.addEventListener("change", () => {
          state.compactDensity = density.checked;
          render();
        });
      }
      const densityMobile = document.getElementById("compactDensityToggleMobile");
      if (densityMobile) {
        densityMobile.checked = !!state.compactDensity;
        densityMobile.addEventListener("change", () => {
          state.compactDensity = densityMobile.checked;
          render();
        });
      }
      // Pagination
      document.querySelectorAll("[data-page]").forEach(btn => {
        btn.addEventListener("click", () => {
          const type = btn.getAttribute("data-page");
          const src = state.currentFilteredOrders?.length ? state.currentFilteredOrders : getBaseOrdersForStatus("all");
          const totalPages = Math.max(1, Math.ceil(src.length / state.ORDERS_PER_PAGE));
          if (type === "first") state.currentPage = 1;
          if (type === "prev") state.currentPage = Math.max(1, state.currentPage - 1);
          if (type === "next") state.currentPage = Math.min(totalPages, state.currentPage + 1);
          if (type === "last") state.currentPage = totalPages;
          render();
        });
      });
      // Select-all checkbox
      const selectAll = document.getElementById("select-all-orders");
      if (selectAll) {
        updateSelectAllCheckboxUI();
        selectAll.addEventListener("change", () => {
          const checked = selectAll.checked;
          Array.from(new Set(state.lastRenderedDeviceKeys.map(k => parseOrderDeviceKey(k).orderId))).forEach(k => setOrderSelected(k, checked));
          render();
        });
      }
      // per-order selection checkbox
      document.querySelectorAll("[data-order-checkbox]").forEach(cb => {
        cb.addEventListener("click", (evt) => evt.stopPropagation());
        cb.addEventListener("change", () => {
          const key = cb.getAttribute("data-order-checkbox");
          setOrderSelected(key, cb.checked);
          updateSelectAllCheckboxUI();
        });
      });
      // open order drawer + hierarchy by clicking order row
      document.querySelectorAll("[data-order-row]").forEach(row => {
        row.addEventListener("click", (e) => {
          if (e.target.closest("a,button,input,label,[data-view-device]")) return;
          const orderId = row.getAttribute("data-order-row");
          if (!orderId) return;
          if (state.expandedOrderIds.has(orderId)) state.expandedOrderIds.delete(orderId);
          else state.expandedOrderIds.add(orderId);
          // Per UX request: clicking order rows should only expand/collapse hierarchy,
          // not open the order drawer popup.
          render();
        });
      });

      // per-order and per-device View buttons are handled by delegated click binding above.
      const btnGen = document.getElementById("bulk-generate-labels");
      if (btnGen) btnGen.addEventListener("click", () => handleBulkLabelGeneration());
      const btnDelete = document.getElementById("bulk-delete-orders");
      if (btnDelete) btnDelete.addEventListener("click", async () => {
        const ids = Array.from(state.selectedOrderIds);
        if (!ids.length) return;
        if (!confirm(`Delete ${ids.length} selected order(s)? This cannot be undone.`)) return;
        let ok = 0;
        const failed = [];
        for (const id of ids) {
          try { await handleAction(id, "deleteOrder"); ok++; } catch (e) { failed.push(id); }
        }
        state.selectedOrderIds = new Set(failed);
        toast(`Deleted ${ok} order(s).${failed.length ? ` ${failed.length} failed.` : ""}`, failed.length ? "error" : "success");
        filterAndRenderOrders(state.currentActiveStatus, state.currentSearchTerm, { preservePage: true });
      });
      const btnBulkApply = document.getElementById("bulk-status-apply");
      if (btnBulkApply) btnBulkApply.addEventListener("click", () => handleBulkStatusUpdate());
      const btnSep = document.getElementById("separate-kit-orders");
      if (btnSep) btnSep.addEventListener("click", () => handleSeparateKitOrders());
      const btnImport = document.getElementById("open-order-text-import");
      if (btnImport) btnImport.addEventListener("click", () => { state.orderTextImportOpen = true; state.modalScrollTop.import = 0; render(); });
      // Drawer close
      document.querySelectorAll("[data-close-drawer]").forEach(el => {
        el.addEventListener("click", () => {
          state.selectedOrderId = null;
          state.selectedOrderSnapshot = null;
          state.selectedDeviceKey = null;
          state.qcDeviceKey = null;
          state.statusDropdownOpen = false;
          state.qcOpen = false;
          state.modalScrollTop.qc = 0;
          state.qcStep = 1;
          state.qcData = null;
          state.reofferOpen = false;
          state.reofferData = null;
          state.modalScrollTop.reoffer = 0;
          render();
        });
      });
      // Drawer tab switching
      document.querySelectorAll("[data-drawer-tab]").forEach(btn => {
        btn.addEventListener("click", () => {
          state.drawerTab = btn.getAttribute("data-drawer-tab");
          render();
        });
      });
      // Drawer status dropdown open/close + outside click
      const modalStatusBtn = document.getElementById("modalStatusBtn");
      if (modalStatusBtn) {
        modalStatusBtn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          state.statusDropdownOpen = !state.statusDropdownOpen;
          render();
        });
      }
      // set status from dropdown
      document.querySelectorAll("[data-set-status]").forEach(btn => {
        btn.addEventListener("click", async (e) => {
          e.preventDefault();
          e.stopPropagation();
          const order = getSelectedOrder();
          if (!order) return;
          const newStatus = btn.getAttribute("data-set-status");
          state.statusDropdownOpen = false;
          render();
          await updateOrderStatusInline(order.id, newStatus, { notifyCustomer: true });
          toast(`Status updated to ${formatStatusLabel(newStatus)}`, "success");
        });
      });
      // outside click closes status dropdown (best-effort)
      document.addEventListener("click", () => {
        if (!state.statusDropdownOpen) return;
        state.statusDropdownOpen = false;
        render();
      }, { once: true });
      // Drawer actions buttons
      const order = getSelectedOrder();
      if (order) {
        document.querySelectorAll("[data-action]").forEach(btn => {
          btn.addEventListener("click", async (e) => {
            e.stopPropagation();
            const action = btn.getAttribute("data-action");
            if (action === "cancelOrder") {
              await handleCancelOrder(order);
              return;
            }
            if (action === "deleteOrder") {
              const ok = confirm("Delete this order? This cannot be undone.");
              if (!ok) return;
              await handleAction(order.id, "deleteOrder");
              state.selectedOrderId = null;
              state.selectedOrderSnapshot = null;
              render();
              return;
            }
            if (action === "reOffer") {
              await openReofferModal(order, state.qcData);
              render();
              return;
            }
            await handleAction(order.id, action);
          });
        });
        // void labels submit
        const voidBtn = document.getElementById("void-label-submit");
        if (voidBtn) {
          voidBtn.addEventListener("click", async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const checks = Array.from(document.querySelectorAll(".void-label-checkbox")).filter(x => x.checked);
            if (!checks.length) {
              toast("Please select at least one label to void.", "error");
              return;
            }
            const selections = checks.map(c => ({
              key: c.getAttribute("data-void-key"),
              id: c.getAttribute("data-void-id"),
            }));
            try {
              const res = await requestVoidLabels(order.id, selections);
              toast(summarizeVoidResults(res), "success");
            } catch (err) {
              toast(`Void failed: ${err?.message || "error"}`, "error");
            }
          });
        }
        // Open QC
        const openQcBtn = document.getElementById("openQcBtn");
        if (openQcBtn) {
          openQcBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            state.qcDeviceKey = state.selectedDeviceKey || buildOrderDeviceKey(order.id, 0);
            state.qcOpen = true;
            state.modalScrollTop.qc = 0;
            state.qcStep = 1;
            state.qcData = null;
            render();
          });
        }
      }
      // QC modal bindings
      if (state.qcOpen && order) {
        const closeBtn = document.getElementById("qcCloseBtn");
        const backBtn = document.getElementById("qcBackBtn");
        const nextBtn = document.getElementById("qcNextBtn");
        const finishBtn = document.getElementById("qcFinishBtn");
        const syncStepInputs = () => {
          document.querySelectorAll('input[name="deviceMatch"]').forEach(r => {
            r.addEventListener("change", async () => { state.qcData.deviceMatch = r.value; if (r.value === 'no') { const models = await getModelsForBrand(state.qcData.actualBrand); if (!state.qcData.actualModelId) state.qcData.actualModelId = models[0]?.id || ''; const storages = await getStorageForModel(state.qcData.actualBrand, state.qcData.actualModelId); if (!state.qcData.actualStorage) state.qcData.actualStorage = storages[0] || ''; } render(); });
          });
          document.querySelectorAll('input[name="storageMatch"]').forEach(r => {
            r.addEventListener("change", async () => {
              state.qcData.storageMatch = r.value;
              if (state.qcData.storageMatch === 'no') {
                const vals = await getStorageForModel(state.qcData.actualBrand, state.qcData.actualModelId);
                if (!state.qcData.actualStorage && vals.length) state.qcData.actualStorage = vals[0];
              }
              render();
            });
          });
          const devName = document.getElementById("qcDeviceName");
          if (devName) devName.addEventListener("input", () => state.qcData.deviceName = devName.value);
          const actualBrand = document.getElementById("qcActualBrand");
          if (actualBrand) actualBrand.addEventListener("change", async () => {
            state.qcData.actualBrand = actualBrand.value;
            const models = await getModelsForBrand(state.qcData.actualBrand);
            state.qcData.actualModelId = models[0]?.id || "";
            const storages = await getStorageForModel(state.qcData.actualBrand, state.qcData.actualModelId);
            state.qcData.actualStorage = storages[0] || "";
            render();
          });
          const actualModel = document.getElementById("qcActualModelId");
          if (actualModel) actualModel.addEventListener("change", async () => {
            state.qcData.actualModelId = actualModel.value;
            const storages = await getStorageForModel(state.qcData.actualBrand, state.qcData.actualModelId);
            if (!storages.includes(state.qcData.actualStorage)) state.qcData.actualStorage = storages[0] || "";
            render();
          });
          const actualStorage = document.getElementById("qcActualStorage");
          if (actualStorage) actualStorage.addEventListener("change", () => {
            state.qcData.actualStorage = actualStorage.value;
          });
          document.querySelectorAll('input[name="isFunctional"]').forEach(r => {
            r.addEventListener("change", () => { state.qcData.isFunctional = r.value; render(); });
          });
          const cond = document.getElementById("qcCondition");
          if (cond) cond.addEventListener("change", () => state.qcData.condition = cond.value);
          const carrier = document.getElementById("qcCarrier");
          if (carrier) carrier.addEventListener("change", () => state.qcData.carrier = carrier.value);
          const damage = document.getElementById("qcHasDamage");
          if (damage) damage.addEventListener("change", () => state.qcData.hasDamage = damage.checked ? "yes" : "no");
          const cracks = document.getElementById("qcHasCracks");
          if (cracks) cracks.addEventListener("change", () => state.qcData.hasCracks = cracks.checked ? "yes" : "no");
          const locked = document.getElementById("qcIsLocked");
          if (locked) locked.addEventListener("change", () => state.qcData.isLocked = locked.checked ? "yes" : "no");
          const fmi = document.getElementById("qcHasFmi");
          if (fmi) fmi.addEventListener("change", () => state.qcData.hasFmi = fmi.checked ? "yes" : "no");
          const bal = document.getElementById("qcHasBalance");
          if (bal) bal.addEventListener("change", () => state.qcData.hasBalance = bal.checked ? "yes" : "no");
          const imei = document.getElementById("qcImei");
          if (imei) imei.addEventListener("input", () => {
            const digitsOnly = imei.value.replace(/\D/g, "").slice(0, 15);
            imei.value = digitsOnly;
            state.qcData.imei = digitsOnly;
          });
          const notes = document.getElementById("qcNotes");
          if (notes) notes.addEventListener("input", () => state.qcData.notes = notes.value);
        };
        if (closeBtn) closeBtn.addEventListener("click", () => { state.qcOpen = false; state.qcStep = 1; state.qcData = null; state.qcDeviceKey = null; render(); });
        if (backBtn) backBtn.addEventListener("click", () => {
          if (state.qcStep === 1) { state.qcOpen = false; state.qcStep = 1; state.qcData = null; state.qcDeviceKey = null; render(); }
          else { state.qcStep -= 1; render(); }
        });
        if (nextBtn) nextBtn.addEventListener("click", () => { state.qcStep += 1; render(); });
        if ((state.qcData?.deviceMatch === 'no' || state.qcData?.storageMatch === 'no') && state.qcData?.actualBrand) {
          getModelsForBrand(state.qcData.actualBrand).then((models) => {
            if (!state.qcData.actualModelId) state.qcData.actualModelId = models[0]?.id || '';
            return getStorageForModel(state.qcData.actualBrand, state.qcData.actualModelId);
          }).then((vals) => {
            if (state.qcData.storageMatch === 'no' && !state.qcData.actualStorage && vals?.length) {
              state.qcData.actualStorage = vals[0];
              render();
            }
          }).catch(() => {});
        }
        if (finishBtn) finishBtn.addEventListener("click", async () => {
          syncStepInputs();
          const qcSnapshot = { ...(state.qcData || {}) };
          await saveQc(order.id, state.qcDeviceKey || buildOrderDeviceKey(order.id, 0), qcSnapshot);
          const qcOutcome = await processQcOutcome(order, qcSnapshot);
          state.qcOpen = false;
          state.qcStep = 1;
          state.qcData = null;
          state.qcDeviceKey = null;
          if (!qcOutcome.sentEmails) {
            await openReofferModal(order, qcSnapshot);
          } else {
            toast("QC saved. Required customer emails sent. Waiting for response.", "info");
          }
          render();
        });
        syncStepInputs();
      }
      if (state.reofferOpen && order) {
        const closeReoffer = () => { state.reofferOpen = false; state.reofferData = null; state.modalScrollTop.reoffer = 0; render(); };
        document.getElementById("reofferCloseBtn")?.addEventListener("click", closeReoffer);
        document.getElementById("reofferCancelBtn")?.addEventListener("click", closeReoffer);
        document.getElementById("reofferSubmitBtn")?.addEventListener("click", async () => {
          const price = Number(document.getElementById("reofferPrice")?.value || 0);
          const reasons = (document.getElementById("reofferReasons")?.value || "").trim();
          const comments = (document.getElementById("reofferComments")?.value || "").trim();
          const carrier = (document.getElementById("reofferCarrier")?.value || "").trim();
          const condition = (document.getElementById("reofferCondition")?.value || "").trim();
          await handleAction(order.id, "reOffer", {
            body: { newPrice: price, reasons: reasons ? reasons.split(/\n+/).map(x => x.trim()).filter(Boolean) : [], comments, carrier, condition }
          });
          state.reofferOpen = false;
          state.reofferData = null;
          state.modalScrollTop.reoffer = 0;
          render();
        });
      }
      // Order text import modal controls
      if (state.orderTextImportOpen) {
        const close = document.getElementById("orderTextImportCloseBtn");
        const cancel = document.getElementById("orderTextImportCancelBtn");
        const submit = document.getElementById("orderTextImportSubmitBtn");
        const closeAll = () => { state.orderTextImportOpen = false; state.modalScrollTop.import = 0; render(); };
        if (close) close.addEventListener("click", closeAll);
        if (cancel) cancel.addEventListener("click", closeAll);
        if (submit) submit.addEventListener("click", () => {
          // placeholder: wire your real handleOrderTextImportSubmit here
          toast("Submit handler placeholder (drop in parser + API call)", "info");
          closeAll();
        });
      }
    }
    // ----------------------------
    // AUTH
    // ----------------------------
    onAuthStateChanged(auth, (u) => {
      state.user = u || null;
      state.authLoading = false;
      if (state.user) {
        startOrdersListener();
      } else {
        if (unsubscribeOrders) unsubscribeOrders();
        unsubscribeOrders = null;
        state.allOrders = [];
        state.currentFilteredOrders = [];
        state.currentActiveStatus = "all";
        state.currentSearchTerm = "";
        state.currentPromoFilter = PROMO_FILTER.ALL;
        state.selectedOrderIds.clear();
        state.lastRenderedDeviceKeys = [];
        state.selectedOrderId = null;
        state.selectedOrderSnapshot = null;
        state.statusDropdownOpen = false;
        state.qcOpen = false;
        state.qcStep = 1;
        state.qcData = null;
        state.reofferOpen = false;
        state.reofferData = null;
        state.orderTextImportOpen = false;
        state.modalScrollTop = { qc: 0, reoffer: 0, import: 0 };
        state.sidebarOpen = false;
      }
      // initial filter
      filterAndRenderOrders(state.currentActiveStatus, state.currentSearchTerm, { preservePage: false });
    });
    // first paint (auth spinner)
    render();
  </script>
</body>
</html>
