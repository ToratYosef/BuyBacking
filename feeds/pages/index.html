<!DOCTYPE html>
<html lang="en">
<head>
    <script>
      window.SHC_API_BASE_URL = "https://shc33.onrender.com/server";
    </script>
<link rel="stylesheet" href="/assets/css/tailwind.css">
  <meta charset="UTF-8">
  <title>Devices CSV → XML Builder</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      padding: 0;
      background: #020617;
      color: #e5e7eb;
    }
    header {
      padding: 1rem 2rem;
      border-bottom: 1px solid #1f2937;
      background: radial-gradient(circle at top left, #1d4ed8, #020617);
    }
    header h1 {
      margin: 0;
      font-size: 1.6rem;
    }
    header p {
      margin: 0.35rem 0 0;
      font-size: 0.9rem;
      color: #9ca3af;
    }
    main {
      padding: 1.5rem;
      max-width: 900px;
      margin: 0 auto;
    }
    .card {
      background: rgba(15, 23, 42, 0.95);
      border-radius: 1rem;
      border: 1px solid rgba(148, 163, 184, 0.25);
      padding: 1rem 1.25rem;
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
      backdrop-filter: blur(12px);
    }
    .card h2 {
      margin: 0 0 0.5rem;
      font-size: 1.15rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .card h2 span {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #60a5fa;
    }
    .card p.description {
      margin: 0 0 0.75rem;
      font-size: 0.85rem;
      color: #9ca3af;
    }
    .field {
      margin-bottom: 0.75rem;
    }
    label {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #9ca3af;
      display: block;
      margin-bottom: 0.25rem;
    }
    input[type="file"] {
      width: 100%;
      box-sizing: border-box;
      border-radius: 0.5rem;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      padding: 0.5rem 0.6rem;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 0.8rem;
    }
    input::file-selector-button {
      border: none;
      padding: 0.35rem 0.75rem;
      margin-right: 0.6rem;
      border-radius: 999px;
      background: #111827;
      color: #e5e7eb;
      cursor: pointer;
      font-size: 0.8rem;
    }
    .small {
      font-size: 0.75rem;
      color: #6b7280;
    }
    button {
      border-radius: 999px;
      border: none;
      padding: 0.5rem 1rem;
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }
    .btn-primary {
      background: linear-gradient(135deg, #2563eb, #22c55e);
      color: white;
      box-shadow: 0 10px 25px rgba(34, 197, 94, 0.35);
    }
    .btn-primary[disabled] {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
    }
    .status-bar {
      margin-top: 0.75rem;
      font-size: 0.75rem;
      color: #9ca3af;
      display: flex;
      justify-content: space-between;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    .status-bar span.highlight {
      color: #22c55e;
    }
    .status-bar span.error {
      color: #f97373;
    }
    textarea {
      width: 100%;
      min-height: 200px;
      box-sizing: border-box;
      border-radius: 0.5rem;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      padding: 0.5rem 0.6rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.8rem;
      resize: vertical;
      margin-top: 0.75rem;
    }
  </style>
</head>
<body>
<header>
  <h1>Devices CSV → XML Builder</h1>
  <p>
    Upload a <code>devices_mapping.csv</code>-style file and we’ll generate
    a <code>devices_from_csv.xml</code> with full price data.
    <strong>Prices are imported and written into the XML.</strong>
  </p>
</header>

<main>
  <section class="card">
    <h2><span>Step 1</span>Upload Devices CSV</h2>
    <p class="description">
      Expected columns (case-insensitive, spaces ignored):
      <code>Device name, Model Id, Storage, Status, Quality, Price, imageUrl, Name, Brand, Deeplink</code>.
    </p>

    <div class="field">
      <label for="csvFile">Devices CSV (devices_mapping.csv)</label>
      <input type="file" id="csvFile" accept=".csv">
      <p class="small">
        Same format as the CSV you exported from your main tool. Each row becomes a
        storage / status / quality / <strong>Price</strong> entry in the XML.
      </p>
    </div>

    <div class="field">
      <button class="btn-primary" id="convertBtn" type="button">Convert to XML &amp; Download</button>
    </div>

    <div class="status-bar" id="statusBar">
      <span><span class="highlight">Idle.</span> Choose a CSV file and click "Convert to XML &amp; Download".</span>
      <span id="stats"></span>
    </div>

    <textarea id="previewArea" readonly placeholder="XML preview will appear here after conversion..."></textarea>
  </section>
</main>

<script>
  const csvFileEl = document.getElementById('csvFile');
  const convertBtn = document.getElementById('convertBtn');
  const statusBarEl = document.getElementById('statusBar');
  const statsEl = document.getElementById('stats');
  const previewAreaEl = document.getElementById('previewArea');

  function setStatus(msg, isError = false) {
    const spans = statusBarEl.querySelectorAll('span');
    if (spans[0]) {
      spans[0].innerHTML = isError
        ? '<span class="error">' + msg + '</span>'
        : '<span class="highlight">' + msg + '</span>';
    }
  }

  function setStats(msg) {
    statsEl.textContent = msg || '';
  }

  function readFileAsText(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = e => resolve(e.target.result);
      reader.onerror = () => reject(reader.error || new Error('File read error'));
      reader.readAsText(file);
    });
  }

  function cleanCsvCell(raw) {
    let s = (raw || '').trim();
    if (s.startsWith('"') && s.endsWith('"')) {
      s = s.slice(1, -1).replace(/""/g, '"');
    }
    return s;
  }

  // Parse devices_mapping.csv-like file
  function parseDevicesCsvText(text) {
    const lines = text.split(/\r?\n/).filter(l => l.trim() !== '');
    if (!lines.length) {
      throw new Error('CSV is empty.');
    }

    const headerCells = lines[0].split(',').map(cleanCsvCell);
    const indexByKey = {};
    headerCells.forEach((h, i) => {
      const key = h.toLowerCase().replace(/\s+/g, '');
      indexByKey[key] = i;
    });

    const requiredKeys = [
      'devicename',
      'modelid',
      'storage',
      'status',
      'quality',
      'price',
      'imageurl',
      'name',
      'brand',
      'deeplink'
    ];
    for (const k of requiredKeys) {
      if (!(k in indexByKey)) {
        throw new Error('Missing required CSV column: ' + k + ' (normalized key).');
      }
    }

    const rows = [];
    for (let i = 1; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line) continue;
      const parts = line.split(',').map(cleanCsvCell);
      if (parts.length < headerCells.length) continue;

      function get(key) {
        const idx = indexByKey[key];
        return cleanCsvCell(parts[idx] ?? '');
      }

      rows.push({
        deviceName: get('devicename'),
        modelId: get('modelid'),
        storage: get('storage'),
        status: get('status'),
        quality: get('quality'),
        price: get('price'),          // RAW PRICE STRING (may include $)
        imageUrl: get('imageurl'),
        name: get('name'),
        brand: get('brand'),
        deeplink: get('deeplink')
      });
    }

    return rows;
  }

  function xmlEscape(str) {
    return String(str ?? '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;');
  }

  // Build XML from parsed rows; includes prices in the correct quality tags
  function buildXmlFromDevicesRows(rows) {
    // Group by model identity: deviceName + modelId + name + brand + imageUrl + deeplink
    const modelsMap = new Map();

    for (const row of rows) {
      const key = [
        row.deviceName,
        row.modelId,
        row.name,
        row.brand,
        row.imageUrl,
        row.deeplink
      ].join('||');

      if (!modelsMap.has(key)) {
        modelsMap.set(key, {
          deviceName: row.deviceName,
          modelId: row.modelId,
          name: row.name,
          brand: row.brand,
          imageUrl: row.imageUrl,
          deeplink: row.deeplink,
          // storage -> status -> quality -> priceNumber
          prices: {}
        });
      }

      const model = modelsMap.get(key);

      const storage = (row.storage || '').trim();
      if (!storage) continue;

      // Normalise status: anything containing "unlock" becomes unlocked, else locked
      let status = (row.status || '').toLowerCase();
      status = status.includes('unlock') ? 'unlocked' : 'locked';

      // Normalise quality to XML tags
      let q = (row.quality || '').toLowerCase().trim();
      // Store as <damaged> in XML
      if (q === 'broken') q = 'damaged';

      const allowedQualities = ['flawless', 'good', 'fair', 'damaged'];
      if (!allowedQualities.includes(q)) continue;

      // CLEAN PRICE STRING BEFORE CONVERTING
      // Handles "$204.00", "204.00", "204", "$ 204.00", "204,00" (comma gets stripped)
      let priceRaw = String(row.price || '');
      let priceClean = priceRaw.replace(/[^0-9.\-]/g, ''); // remove $, commas, spaces, etc.
      const priceNum = Number(priceClean);
      if (Number.isNaN(priceNum)) continue;  // skip rows with bad price

      if (!model.prices[storage]) model.prices[storage] = {};
      if (!model.prices[storage][status]) model.prices[storage][status] = {};
      model.prices[storage][status][q] = priceNum; // PRICE STORED HERE
    }

    // Build XML string
    let xml = "<?xml version='1.0' encoding='UTF-8'?>\n<models>\n";

    const qualityOrder = ['flawless', 'good', 'fair', 'damaged'];
    const statusOrder = ['locked', 'unlocked'];

    for (const model of modelsMap.values()) {
      xml += '  <model>\n';
      xml += '    <parentDevice>' + xmlEscape(model.deviceName) + '</parentDevice>\n';
      xml += '    <modelID>' + xmlEscape(model.modelId) + '</modelID>\n';

      // Build <prices> blocks for each storage
      const storageKeys = Object.keys(model.prices).sort();
      for (const storage of storageKeys) {
        xml += '    <prices>\n';
        xml += '      <storageSize>' + xmlEscape(storage) + '</storageSize>\n';
        xml += '      <priceValue>\n';

        for (const status of statusOrder) {
          const bucket = model.prices[storage][status];
          if (!bucket) continue;

          xml += '        <' + status + '>\n';
          for (const q of qualityOrder) {
            const priceNum = bucket[q];
            if (priceNum == null) continue;
            xml +=
              '          <' + q + '>' +
              priceNum.toFixed(2) +
              '</' + q + '>\n'; // PRICE WRITTEN INTO XML TAG
          }
          xml += '        </' + status + '>\n';
        }

        xml += '      </priceValue>\n';
        xml += '    </prices>\n';
      }

      // Metadata
      xml += '    <slug>' + xmlEscape(model.modelId) + '</slug>\n';
      xml += '    <imageUrl>' + xmlEscape(model.imageUrl) + '</imageUrl>\n';
      xml += '    <name>' + xmlEscape(model.name) + '</name>\n';
      xml += '    <brand>' + xmlEscape(model.brand) + '</brand>\n';
      xml += '    <deeplink>' + xmlEscape(model.deeplink) + '</deeplink>\n';
      xml += '  </model>\n';
    }

    xml += '</models>\n';
    return xml;
  }

  async function handleConvert() {
    const file = csvFileEl.files && csvFileEl.files[0];
    if (!file) {
      setStatus('Upload a devices CSV first.', true);
      return;
    }

    setStatus('Reading devices CSV…', false);
    setStats('');
    previewAreaEl.value = '';

    let text;
    try {
      text = await readFileAsText(file);
    } catch (err) {
      console.error(err);
      setStatus('Error reading devices CSV file.', true);
      return;
    }

    let rows;
    try {
      rows = parseDevicesCsvText(text);
    } catch (err) {
      console.error(err);
      setStatus(err.message || 'Error parsing devices CSV.', true);
      return;
    }

    if (!rows.length) {
      setStatus('Devices CSV contains no data rows.', true);
      return;
    }

    const xml = buildXmlFromDevicesRows(rows);
    previewAreaEl.value = xml;

    // Download XML as file
    const blob = new Blob([xml], { type: 'application/xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'devices_from_csv.xml';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    setStatus('Conversion complete. devices_from_csv.xml downloaded.', false);
    setStats('Rows parsed: ' + rows.length);
  }

  convertBtn.addEventListener('click', () => {
    handleConvert().catch(err => {
      console.error(err);
      setStatus('Unexpected error during conversion.', true);
    });
  });
</script>
  <script type="module" src="/assets/js/global-auth.js" defer></script>
</body>
</html>
