<!DOCTYPE html>
<html lang="en">
<head>
    <script>
      window.SHC_API_BASE_URL = "https://api.secondhandcell.com/";
    </script>
<link rel="stylesheet" href="/assets/css/tailwind.css">
  <meta charset="UTF-8" />
  <title>SecondHandCell Repricer – SellCell + Amazon (Local XML)</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: #020617;
      color: #e5e7eb;
    }
    header {
      padding: 1.2rem 2rem;
      border-bottom: 1px solid #1f2937;
      background: radial-gradient(circle at top left, #1d4ed8, #020617);
    }
    header h1 {
      margin: 0;
      font-size: 1.8rem;
    }
    header p {
      margin: 0.4rem 0 0;
      font-size: 0.9rem;
      color: #9ca3af;
    }
    main {
      padding: 1.5rem;
      max-width: 1700px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 2fr);
      gap: 1.5rem;
    }
    .card {
      background: rgba(15, 23, 42, 0.95);
      border-radius: 0.75rem;
      border: 1px solid #1f2937;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
      padding: 1.25rem 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .card h2 {
      margin: 0;
      font-size: 1.1rem;
      color: #e5e7eb;
    }
    .muted {
      font-size: 0.85rem;
      color: #9ca3af;
      line-height: 1.4;
    }
    textarea {
      width: 100%;
      min-height: 260px;
      resize: vertical;
      border-radius: 0.5rem;
      border: 1px solid #1f2937;
      background: #020617;
      color: #e5e7eb;
      padding: 0.75rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.85rem;
      white-space: pre;
    }
    textarea:focus {
      outline: 2px solid #3b82f6;
      outline-offset: 1px;
    }
    .file-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-top: 0.25rem;
    }
    .file-label {
      font-size: 0.85rem;
      color: #e5e7eb;
      min-width: 90px;
    }
    input[type="file"] {
      font-size: 0.8rem;
      color: #e5e7eb;
    }
    input[type="number"] {
      width: 100px;
      padding: 0.35rem 0.5rem;
      border-radius: 0.3rem;
      border: 1px solid #1f2937;
      background: #020617;
      color: #e5e7eb;
      font-size: 0.9rem;
    }
    input[type="number"]:focus {
      outline: 2px solid #3b82f6;
      outline-offset: 1px;
    }
    .new-variant-row {
      background: rgba(59, 130, 246, 0.2) !important;
      border-left: 3px solid #3b82f6;
    }
    .badge-new {
      display: inline-block;
      padding: 0.05rem 0.45rem;
      border-radius: 999px;
      font-size: 0.7rem;
      background: #3b82f6;
      color: #fff;
      margin-left: 0.5rem;
    }
    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-top: 0.75rem;
      align-items: center;
    }
    button {
      border: none;
      border-radius: 999px;
      padding: 0.55rem 1.4rem;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      background: linear-gradient(135deg, #2563eb, #4f46e5);
      color: #f9fafb;
      box-shadow: 0 8px 20px rgba(37, 99, 235, 0.35);
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      transition: transform 0.08s ease, box-shadow 0.08s ease, opacity 0.1s ease;
    }
    button.secondary {
      background: transparent;
      border: 1px solid #1f2937;
      box-shadow: none;
      color: #e5e7eb;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
      transform: none;
    }
    button:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 26px rgba(37, 99, 235, 0.5);
    }
    button .pill {
      background: rgba(15, 23, 42, 0.9);
      padding: 0.05rem 0.5rem;
      border-radius: 999px;
      font-size: 0.75rem;
      color: #cbd5f5;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.84rem;
    }
    thead {
      position: sticky;
      top: 0;
      background: #020617;
      z-index: 1;
    }
    th, td {
      padding: 0.35rem 0.5rem;
      text-align: left;
      white-space: nowrap;
    }
    th {
      font-weight: 600;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      border-bottom: 1px solid #111827;
      color: #9ca3af;
      background: radial-gradient(circle at top left, #111827, #020617);
    }
    tbody tr:nth-child(even) td {
      background: rgba(15, 23, 42, 0.85);
    }
    tbody tr:nth-child(odd) td {
      background: rgba(15, 23, 42, 0.6);
    }
    tbody tr:hover td {
      background: rgba(37, 99, 235, 0.15);
    }
    .number {
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
    .status-ok {
      color: #22c55e;
    }
    .status-warn {
      color: #f97316;
    }
    .status-err {
      color: #f97373;
    }
    .badge {
      display: inline-block;
      padding: 0.05rem 0.45rem;
      border-radius: 999px;
      font-size: 0.7rem;
      border: 1px solid rgba(156, 163, 175, 0.4);
      background: rgba(15, 23, 42, 0.9);
      color: #e5e7eb;
    }
    .scroll-table {
      border-radius: 0.5rem;
      overflow: auto;
      max-height: 620px;
      border: 1px solid #1f2937;
    }
    #statusText {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-top: 0.25rem;
    }
    #errorBox {
      margin-top: 0.5rem;
      font-size: 0.82rem;
      color: #fecaca;
      background: rgba(127, 29, 29, 0.4);
      border-radius: 0.4rem;
      border: 1px solid rgba(248, 113, 113, 0.5);
      padding: 0.4rem 0.55rem;
      display: none;
      white-space: pre-wrap;
    }
    .pill-small {
      font-size: 0.75rem;
      color: #9ca3af;
    }
    @media (max-width: 1200px) {
      main {
        grid-template-columns: minmax(0, 1fr);
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>SecondHandCell Repricer – SellCell + Amazon (Local XML)</h1>
    <p>Upload CSV ➜ upload SellCell feed XML ➜ (optional) upload Template XML ➜ get repriced values ➜ output CSV or updated device-prices XML (AT&amp;T / Verizon / T-Mobile / Unlocked).</p>
  </header>

  <main>
    <section class="card">
      <h2>Step 1 – Input CSV & XML</h2>
      <div class="muted">
        <strong>Expected CSV columns</strong> (header row, comma-separated):<br>
        <code>name,storage,lock_status,condition,price,amz</code><br>
        <span class="pill-small">
          lock_status can be: att, verizon, tmobile, unlocked (or legacy locked/unlocked);
          price = current buy price; amz = Amazon price.
        </span>
      </div>

      <textarea id="csvInput" placeholder="Paste your CSV here (including header)..."></textarea>

      <div class="file-row">
        <span class="file-label">CSV file</span>
        <input type="file" id="csvFile" accept=".csv,text/csv" />
      </div>

      <div class="file-row">
        <span class="file-label">SellCell XML</span>
        <input type="file" id="xmlFile" accept=".xml,text/xml" />
      </div>

      <div class="file-row">
        <span class="file-label">Template XML</span>
        <input type="file" id="templateXmlFile" accept=".xml,text/xml" />
      </div>

      <div class="file-row" style="margin-top: 0.75rem;">
        <span class="file-label">Price Increase ($)</span>
        <input type="number" id="priceIncreaseAmount" value="1.00" min="0" step="0.01" />
      </div>
      <div class="btn-row">
        <button id="btnProcessLocal">
          Use CSV + XML
          <span class="pill">local only</span>
        </button>
        <button id="btnDownload" class="secondary" disabled>
          Download CSV
        </button>
        <button id="btnDownloadXml" class="secondary" disabled>
          Download XML
        </button>
        <button id="btnExportMatchingCsv" class="secondary" disabled>
          Export to CSV (Original Format)
        </button>
        <button id="btnShowNewOnly" class="secondary" disabled>
          Show New Variants Only
        </button>
        <button id="btnShowAll" class="secondary" disabled style="display:none;">
          Show All
        </button>
      </div>

      <div id="statusText">Ready.</div>
      <div id="errorBox"></div>
      <div class="muted" style="margin-top:0.5rem;">
        Processed rows: <span id="processedCount">0</span>
      </div>
    </section>

    <section class="card">
      <h2>Step 2 – Preview Results</h2>
      <div class="muted">
        After processing, new buy prices will appear below. Each row uses the correct carrier (AT&amp;T / Verizon / T-Mobile / Unlocked) from the feed.
      </div>
      <div class="scroll-table">
        <table id="resultTable">
          <thead>
            <tr>
              <th>name</th>
              <th>storage</th>
              <th>lock_status</th>
              <th>condition</th>
              <th>Feed</th>
              <th>Amazon</th>
              <th>Walkaway</th>
              <th>Profit $</th>
              <th>Profit %</th>
              <th>New price</th>
              <th>New profit</th>
              <th>New pr</th>
              <th>Status</th>
              <th>AMZ Price Input</th>
            </tr>
          </thead>
          <tbody id="resultBody">
          </tbody>
        </table>
      </div>
    </section>
  </main>

  <script>
    // ===================== NAME NORMALIZATION + ALIASES =====================

    // Map internal names -> SellCell's device_name
    // Keys and values are stored UPPERCASE for easy matching.
    const MODEL_ALIASES = {
      // ---- iPhone 16e → iPhone SE 3rd Gen (2022) ----
      "IPHONE 16 SE": "IPHONE SE 3RD GEN (2022)",
      "IPHONE 16E": "IPHONE SE 3RD GEN (2022)",
      "IPHONE SE 3": "IPHONE SE 3RD GEN (2022)",
      "IPHONE SE 2022": "IPHONE SE 3RD GEN (2022)",
      "IPHONE SE 3RD GEN": "IPHONE SE 3RD GEN (2022)",

      // ---- Galaxy S “Plus” models ----
      "GALAXY S21+": "GALAXY S21 PLUS",
      "GALAXY S22+": "GALAXY S22 PLUS",
      "GALAXY S23+": "GALAXY S23 PLUS",
      "GALAXY S24+": "GALAXY S24 PLUS",
      "GALAXY S25+": "GALAXY S25 PLUS",

      // ---- Galaxy S FE weird spacing ----
      "GALAXY S23FE": "GALAXY S23 FE",

      // ---- Galaxy Z Flip series (space vs no space) ----
      "GALAXY Z FLIP 4": "GALAXY Z FLIP4",
      "GALAXY Z FLIP 5": "GALAXY Z FLIP5",
      "GALAXY Z FLIP 6": "GALAXY Z FLIP6",

      // ---- Galaxy Z Fold series (space vs no space) ----
      "GALAXY Z FOLD 4": "GALAXY Z FOLD4",
      "GALAXY Z FOLD 5": "GALAXY Z FOLD5",
      "GALAXY Z FOLD 6": "GALAXY Z FOLD6",
    };

    // Normalization used when building the feed index (on XML device_name).
    function normalizeModelNameForFeed(rawName) {
      if (!rawName) return "";
      let upper = rawName
        .toString()
        .toUpperCase()
        .replace(/\s+/g, " ")
        .trim();
      if (MODEL_ALIASES[upper]) {
        return MODEL_ALIASES[upper];
      }
      return upper;
    }

    // NEW: Normalization used for CSV rows, aware of storage.
    // If the CSV name ends with the storage (e.g. "PIXEL 10 128GB" + storage "128GB"),
    // strip that off so it matches SellCell's device_name ("PIXEL 10").
    function normalizeModelNameFromCsv(rawName, storage) {
      if (!rawName) return "";
      let upper = rawName
        .toString()
        .toUpperCase()
        .replace(/\s+/g, " ")
        .trim();

      const storageNorm = (storage || "").toString().toUpperCase().trim();
      if (storageNorm && upper.endsWith(" " + storageNorm)) {
        // Remove the trailing " 128GB" / " 256GB" / etc.
        upper = upper.slice(0, upper.length - storageNorm.length).trim();
      }

      if (MODEL_ALIASES[upper]) {
        return MODEL_ALIASES[upper];
      }
      return upper;
    }

    // Backwards-compatible wrapper (if something else calls it)
    function normalizeName(name) {
      return normalizeModelNameForFeed(name);
    }

    // ===================== CARRIER NORMALIZATION =====================

    // Normalize CSV lock_status into carrier tag names used in XML: att, verizon, tmobile, unlocked
    function normalizeCarrierLock(lockStatusRaw) {
      if (!lockStatusRaw) return null;
      const s = String(lockStatusRaw).trim().toLowerCase();
      if (s === "att" || s === "at&t") return "att";
      if (s === "verizon") return "verizon";
      if (s === "unlocked") return "unlocked";
      if (s === "tmobile" || s === "t-mobile" || s === "t mobile") return "tmobile";
      // Legacy "locked" → treat as Verizon
      if (s === "locked") return "verizon";
      return null;
    }

    // Normalize feed <network> to carrier bucket
    function normalizeCarrierFromNetwork(networkRaw) {
      if (!networkRaw) return null;
      const s = String(networkRaw).trim().toLowerCase();
      if (s.includes("at&t") || s === "att") return "att";
      if (s === "verizon") return "verizon";
      if (s === "unlocked" || s === "sim-free" || s === "sim free") return "unlocked";
      if (s.includes("t-mobile") || s === "tmobile" || s === "t mobile") return "tmobile";
      return null; // other networks feed into "any"
    }

    // ---------- Helpers ----------
    function showError(msg, err) {
      console.error("[repricer] ERROR:", msg, err || "");
      const box = document.getElementById("errorBox");
      box.style.display = "block";
      box.textContent = msg + (err && err.message ? "\n" + err.message : "");
      document.getElementById("statusText").textContent = "Error – see details below.";
    }

    function clearError() {
      const box = document.getElementById("errorBox");
      box.style.display = "none";
      box.textContent = "";
    }

    function setStatus(msg) {
      console.log("[repricer]", msg);
      document.getElementById("statusText").textContent = msg;
    }

    function parseMoney(value) {
      if (value == null) return null;
      const cleaned = String(value).replace(/[^0-9.\-]/g, "");
      if (!cleaned) return null;
      const num = parseFloat(cleaned);
      return Number.isFinite(num) ? num : null;
    }

    // CSV parser that handles quotes and commas in quotes.
    function parseCsv(text) {
      if (!text) return [];
      const rows = [];
      let cur = "";
      let row = [];
      let inQuotes = false;

      for (let i = 0; i < text.length; i++) {
        const ch = text[i];
        const next = text[i + 1];

        if (ch === '"') {
          if (inQuotes && next === '"') {
            cur += '"';
            i++;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (ch === ',' && !inQuotes) {
          row.push(cur);
          cur = "";
        } else if ((ch === '\n' || ch === '\r') && !inQuotes) {
          if (cur.length || row.length) {
            row.push(cur);
            rows.push(row);
            row = [];
            cur = "";
          }
          if (ch === '\r' && next === '\n') {
            i++;
          }
        } else {
          cur += ch;
        }
      }
      if (cur.length || row.length) {
        row.push(cur);
        rows.push(row);
      }
      return rows;
    }

    function csvToRecords(text) {
      const rows = parseCsv(text.trim());
      if (!rows.length) return [];
      const header = rows[0].map(h => String(h || "").trim());
      const records = [];
      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];
        if (!r || r.length === 0 || (r.length === 1 && !r[0].trim())) continue;
        const obj = {};
        for (let j = 0; j < header.length; j++) {
          obj[header[j]] = r[j] != null ? r[j] : "";
        }
        records.push(obj);
      }
      return records;
    }

    // ===================== FEED INDEX (CARRIER-SPECIFIC) =====================

    // key: "DEVICE_NAME|CAPACITY"
    // value:
    //   {
    //     att:      { flawless, good, fair, damaged }
    //     verizon:  { flawless, good, fair, damaged }
    //     tmobile:  { flawless, good, fair, damaged }
    //     unlocked: { flawless, good, fair, damaged }
    //     any:      { flawless, good, fair, damaged }   // max across all networks
    //     _modelName: "DEVICE_NAME"
    //     _storage: "CAPACITY"
    //   }
    function buildFeedIndexFromXml(xmlText) {
      setStatus("Parsing XML feed...");
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xmlText, "application/xml");
      const parseErr = xmlDoc.querySelector("parsererror");
      if (parseErr) {
        throw new Error("XML parse error: " + parseErr.textContent.trim());
      }

      const CONDITION_XML_MAP = {
        flawless: "prices_likenew",
        good: "prices_good",
        fair: "prices_poor",
        damaged: "prices_faulty",
      };

      const devices = xmlDoc.getElementsByTagName("device");
      const index = {};
      let deviceCount = 0;

      for (let i = 0; i < devices.length; i++) {
        const d = devices[i];
        const nameEl = d.getElementsByTagName("device_name")[0];
        const capEl = d.getElementsByTagName("capacity")[0];
        const netEl = d.getElementsByTagName("network")[0];

        const deviceName = normalizeModelNameForFeed(nameEl ? nameEl.textContent : "");
        const capacity = String(capEl ? capEl.textContent : "").trim().toUpperCase();
        const networkRaw = netEl ? netEl.textContent : "";
        const carrierBucket = normalizeCarrierFromNetwork(networkRaw);

        if (!deviceName || !capacity) continue;

        const keyBase = deviceName + "|" + capacity;

        if (!index[keyBase]) {
          index[keyBase] = {
            att: {},
            verizon: {},
            tmobile: {},
            unlocked: {},
            any: {},
            _modelName: deviceName,
            _storage: capacity,
          };
        }

        deviceCount++;

        for (const condKey of Object.keys(CONDITION_XML_MAP)) {
          const sectionTag = CONDITION_XML_MAP[condKey];
          const section = d.getElementsByTagName(sectionTag)[0];
          if (!section) continue;
          const prices = Array.from(section.getElementsByTagName("price"));
          if (!prices.length) continue;

          const competitorPrices = prices
            .map(p => {
              const mEl = p.getElementsByTagName("merchant_name")[0];
              const priceEl = p.getElementsByTagName("merchant_price")[0];
              const merchant = String(mEl ? mEl.textContent : "").trim().toLowerCase();
              if (merchant === "secondhandcell") return null;
              const v = parseMoney(priceEl ? priceEl.textContent : "");
              return Number.isFinite(v) ? v : null;
            })
            .filter(v => v != null);

          if (!competitorPrices.length) continue;
          const top = Math.max.apply(null, competitorPrices);

          if (carrierBucket && index[keyBase][carrierBucket]) {
            const bucket = index[keyBase][carrierBucket];
            if (!bucket[condKey] || top > bucket[condKey]) {
              bucket[condKey] = top;
            }
          }

          const anyBucket = index[keyBase].any;
          if (!anyBucket[condKey] || top > anyBucket[condKey]) {
            anyBucket[condKey] = top;
          }
        }
      }

      console.log("[repricer] Built feed index", { deviceCount, keyCount: Object.keys(index).length });
      setStatus("XML parsed – indexed " + Object.keys(index).length + " model/storage combos.");
      return index;
    }

    // Detect missing storage variants vs the feed and create placeholder rows
    function detectAndAddMissingVariants(csvRecords, feedIndex) {
      const existingCombos = new Set();
      const modelStoragesInCsv = {};

      csvRecords.forEach(r => {
        const modelName = normalizeModelNameFromCsv(r.name, r.storage);
        const storage = String(r.storage || "").trim().toUpperCase();
        const key = modelName + "|" + storage;
        existingCombos.add(key);

        if (!modelStoragesInCsv[modelName]) {
          modelStoragesInCsv[modelName] = new Set();
        }
        modelStoragesInCsv[modelName].add(storage);
      });

      const feedModelStorages = {};
      Object.keys(feedIndex).forEach(key => {
        const entry = feedIndex[key];
        const modelName = entry._modelName;
        const storage = entry._storage;

        if (!feedModelStorages[modelName]) {
          feedModelStorages[modelName] = new Set();
        }
        feedModelStorages[modelName].add(storage);
      });

      const newVariants = [];
      const carriers = ["att", "verizon", "tmobile", "unlocked"];
      const conditions = ["flawless", "good", "fair", "damaged"];

      Object.keys(modelStoragesInCsv).forEach(modelName => {
        const csvStorages = modelStoragesInCsv[modelName];
        const feedStorages = feedModelStorages[modelName];

        if (feedStorages) {
          feedStorages.forEach(feedStorage => {
            if (!csvStorages.has(feedStorage)) {
              carriers.forEach(carrier => {
                conditions.forEach(condition => {
                  const sampleRow = csvRecords.find(r =>
                    normalizeModelNameFromCsv(r.name, r.storage) === modelName
                  );
                  if (sampleRow) {
                    newVariants.push({
                      name: sampleRow.name,
                      storage: feedStorage,
                      lock_status: carrier,
                      condition: condition,
                      price: "",
                      amz: "",
                      _isNewVariant: true,
                    });
                  }
                });
              });
            }
          });
        }
      });

      console.log(`[repricer] Found ${newVariants.length} new storage variants`);
      return newVariants;
    }

    // ===================== REPRICER LOGIC =====================

    function repriceRowFromFeed(row, feedIndex, priceIncrease) {
      const result = { ...row };

      const name = row.name;
      const storage = String(row.storage || "").trim().toUpperCase();
      const conditionRaw = row.condition;
      const condition = String(conditionRaw || "").toLowerCase();
      const carrierLock = normalizeCarrierLock(row.lock_status);

      const key = normalizeModelNameFromCsv(name, storage) + "|" + storage;
      const feedEntry = feedIndex[key];

      let status = "";
      let statusClass = "status-ok";

      let feedPrice = null;
      const condKey = condition;

      if (feedEntry) {
        let bucket = null;

        if (carrierLock && feedEntry[carrierLock] && feedEntry[carrierLock][condKey] != null) {
          bucket = feedEntry[carrierLock];
        } else if (feedEntry.unlocked && feedEntry.unlocked[condKey] != null && carrierLock === "unlocked") {
          bucket = feedEntry.unlocked;
        } else if (feedEntry.any && feedEntry.any[condKey] != null) {
          bucket = feedEntry.any;
        }

        if (bucket && bucket[condKey] != null) {
          feedPrice = bucket[condKey];
        }
      }

      if (!feedPrice) {
        status = "No competitor feed price found for this carrier";
        statusClass = "status-warn";
      }

      result.original_feed_price = feedPrice != null ? feedPrice : null;

      const amazonPrice = parseMoney(row.amz);
      if (!amazonPrice) {
        result.amazon_price = null;
        result.after_amazon = null;
        result.sellcell_fee = null;
        result.shipping_fee = 15;
        result.condition_fee = null;
        result.total_walkaway = null;
        result.profit = null;
        result.profit_pct = null;
        result.new_price = null;
        result.new_profit = null;
        result.new_profit_pct = null;

        if (status) {
          status += " & no valid Amazon price";
        } else {
          status = "No valid Amazon price";
        }
        statusClass = "status-warn";

        result._status = status;
        result._statusClass = statusClass;
        return result;
      }

      result.amazon_price = amazonPrice;

      if (!feedPrice) {
        result.after_amazon = null;
        result.sellcell_fee = null;
        result.shipping_fee = 15;
        result.condition_fee = null;
        result.total_walkaway = null;
        result.profit = null;
        result.profit_pct = null;
        result.new_price = null;
        result.new_profit = null;
        result.new_profit_pct = null;

        if (!status) status = "No competitor feed price found for this carrier";
        statusClass = "status-warn";
        result._status = status;
        result._statusClass = statusClass;
        return result;
      }

      const after_amazon = amazonPrice * 0.92 - 10;
      const sellcell_fee = Math.min(after_amazon * 0.08, 30);
      const after_sellcell = after_amazon - sellcell_fee;
      const shipping_fee = 15;

      let condition_fee = 0;
      if (condition === "flawless" || condition === "good") {
        condition_fee = 10;
      } else if (condition === "fair") {
        condition_fee = 30;
      } else if (condition === "damaged") {
        condition_fee = 50;
      }

      const total_walkaway = after_sellcell - shipping_fee - condition_fee;
      const original_price = feedPrice;
      const profit = total_walkaway - original_price;
      const profit_pct = original_price ? profit / original_price : null;

      let new_price;
      if (profit_pct != null && profit_pct >= 0.15) {
        new_price = original_price + priceIncrease;
      } else {
        new_price = total_walkaway / 1.15;
      }
      new_price = Math.round(new_price * 100) / 100;

      const new_profit = total_walkaway - new_price;
      const new_profit_pct = new_price ? new_profit / new_price : null;

      result.after_amazon = after_amazon;
      result.sellcell_fee = sellcell_fee;
      result.shipping_fee = shipping_fee;
      result.condition_fee = condition_fee;
      result.total_walkaway = total_walkaway;
      result.profit = profit;
      result.profit_pct = profit_pct;
      result.new_price = new_price;
      result.new_profit = new_profit;
      result.new_profit_pct = new_profit_pct;

      if (profit_pct != null && profit_pct >= 0.15) {
        status = `Already ≥ 15% profit – bumped $${priceIncrease.toFixed(2)}`;
        statusClass = "status-ok";
      } else {
        status = "Repriced to hit 15% profit";
        statusClass = "status-ok";
      }

      result._status = status;
      result._statusClass = statusClass;
      return result;
    }

    // ===================== RENDER + CSV EXPORT =====================

    let allResultRows = [];
    let showingNewOnly = false;

    function renderResults(rows) {
      const tbody = document.getElementById("resultBody");
      tbody.innerHTML = "";

      function fmtMoney(v) {
        if (v == null || !Number.isFinite(v)) return "";
        return "$" + v.toFixed(2);
      }
      function fmtPct(v) {
        if (v == null || !Number.isFinite(v)) return "";
        return (v * 100).toFixed(2) + "%";
      }

      rows.forEach((r) => {
        const tr = document.createElement("tr");
        if (r._isNewVariant) {
          tr.style.background = "rgba(59, 130, 246, 0.2)";
        }

        const cells = [
          r.name,
          r.storage,
          r.lock_status,
          r.condition,
          fmtMoney(r.original_feed_price),
          fmtMoney(r.amazon_price),
          fmtMoney(r.total_walkaway),
          fmtMoney(r.profit),
          fmtPct(r.profit_pct),
          fmtMoney(r.new_price),
          fmtMoney(r.new_profit),
          fmtPct(r.new_profit_pct),
        ];

        const alignRightIdx = [4,5,6,7,8,9,10,11];

        cells.forEach((val, idx) => {
          const td = document.createElement("td");
          td.textContent = val != null ? val : "";
          if (alignRightIdx.includes(idx)) {
            td.classList.add("number");
          }
          tr.appendChild(td);
        });

        const statusTd = document.createElement("td");
        const span = document.createElement("span");
        span.textContent = r._status || "";
        span.className = r._statusClass || "";
        statusTd.appendChild(span);
        tr.appendChild(statusTd);

        const amzInputTd = document.createElement("td");
        if (r._isNewVariant) {
          const input = document.createElement("input");
          input.type = "number";
          input.step = "0.01";
          input.min = "0";
          input.placeholder = "Enter AMZ price";
          input.style.width = "120px";
          input.style.padding = "0.35rem 0.5rem";
          input.style.borderRadius = "0.3rem";
          input.style.border = "1px solid #1f2937";
          input.style.background = "#020617";
          input.style.color = "#e5e7eb";
          input.style.fontSize = "0.9rem";

          input.addEventListener("change", (e) => {
            const newAmzPrice = parseFloat(e.target.value);
            if (newAmzPrice && newAmzPrice > 0) {
              allResultRows[r._originalIndex].amz = newAmzPrice;
              const priceIncreaseAmount = parseMoney(document.getElementById("priceIncreaseAmount").value) || 1.00;
              const feedIndex = window._currentFeedIndex || {};
              const updatedRow = repriceRowFromFeed(allResultRows[r._originalIndex], feedIndex, priceIncreaseAmount);
              updatedRow._isNewVariant = true;
              updatedRow._originalIndex = r._originalIndex;
              allResultRows[r._originalIndex] = updatedRow;

              if (showingNewOnly) {
                const newVariants = allResultRows.filter(row => row._isNewVariant);
                renderResults(newVariants);
              } else {
                renderResults(allResultRows);
              }
            }
          });

          amzInputTd.appendChild(input);
        } else {
          amzInputTd.textContent = "-";
        }
        tr.appendChild(amzInputTd);

        tbody.appendChild(tr);
      });

      document.getElementById("processedCount").textContent = allResultRows.length.toString();
    }

    function buildOutputCsv(rows) {
      const header = [
        "name",
        "storage",
        "lock_status",
        "condition",
        "price",
        "amz",
        "original_feed_price",
        "amazon_price",
        "after_amazon",
        "sellcell_fee",
        "shipping_fee",
        "condition_fee",
        "total_walkaway",
        "profit",
        "profit_pct",
        "new_price",
        "new_profit",
        "new_profit_pct",
        "status",
      ];

      function escapeCsv(value) {
        if (value == null) return "";
        const s = String(value);
        if (/[",\n\r]/.test(s)) {
          return '"' + s.replace(/"/g, '""') + '"';
        }
        return s;
      }

      const lines = [header.join(",")];
      for (const r of rows) {
        const row = [
          r.name,
          r.storage,
          r.lock_status,
          r.condition,
          r.price,
          r.amz,
          r.original_feed_price != null ? r.original_feed_price.toFixed(2) : "",
          r.amazon_price != null ? r.amazon_price.toFixed(2) : "",
          r.after_amazon != null ? r.after_amazon.toFixed(2) : "",
          r.sellcell_fee != null ? r.sellcell_fee.toFixed(2) : "",
          r.shipping_fee != null ? r.shipping_fee.toFixed(2) : "",
          r.condition_fee != null ? r.condition_fee.toFixed(2) : "",
          r.total_walkaway != null ? r.total_walkaway.toFixed(2) : "",
          r.profit != null ? r.profit.toFixed(2) : "",
          r.profit_pct != null ? (r.profit_pct * 100).toFixed(2) + "%" : "",
          r.new_price != null ? r.new_price.toFixed(2) : "",
          r.new_profit != null ? r.new_profit.toFixed(2) : "",
          r.new_profit_pct != null ? (r.new_profit_pct * 100).toFixed(2) + "%" : "",
          r._status || "",
        ];
        lines.push(row.map(escapeCsv).join(","));
      }
      return lines.join("\n");
    }

    function buildMatchingFormatCsv(rows) {
      const header = ["name", "storage", "lock_status", "condition", "price", "amz"];

      function escapeCsv(value) {
        if (value == null) return "";
        const s = String(value);
        if (/[",\n\r]/.test(s)) {
          return '"' + s.replace(/"/g, '""') + '"';
        }
        return s;
      }

      function fmtMoney(v) {
        if (v == null || !Number.isFinite(v)) return "";
        return "$" + v.toFixed(2);
      }

      const lines = [header.join(",")];
      for (const r of rows) {
        const row = [
          r.name,
          r.storage,
          r.lock_status,
          r.condition,
          fmtMoney(r.new_price),
          fmtMoney(r.amazon_price || parseMoney(r.amz)),
        ];
        lines.push(row.map(escapeCsv).join(","));
      }
      return lines.join("\n");
    }

    // ===================== XML PRETTY PRINT HELPER =====================

    function prettyPrintXml(xml) {
      const PADDING = "  "; // 2 spaces
      const reg = /(>)(<)(\/*)/g;

      // Put each tag on its own line first
      xml = xml.replace(reg, "$1\n$2$3");

      const lines = xml.split("\n");
      let pad = 0;
      const result = [];

      for (let rawLine of lines) {
        let line = rawLine.trim();
        if (!line) continue;

        // Closing tag: decrease indent first
        if (/^<\/.+>/.test(line)) {
          pad = Math.max(pad - 1, 0);
        }

        let indent = "";
        for (let i = 0; i < pad; i++) {
          indent += PADDING;
        }

        result.push(indent + line);

        // Opening tag that is not self-closing and not on same line as its closing tag
        if (
          /^<[^!?][^>]*[^/]>$/.test(line) &&      // <tag> (not <?xml, <!DOCTYPE, <tag />, etc)
          !/<\/.+>$/.test(line)                   // and not <tag>...</tag> on one line
        ) {
          pad++;
        }
      }

      return result.join("\n");
    }

    // ===================== XML EXPORT (CARRIER FORMAT) =====================

    function buildUpdatedXmlFromTemplate(templateXmlText, rows) {
      setStatus("Building updated XML from template...");
      const parser = new DOMParser();
      const doc = parser.parseFromString(templateXmlText, "application/xml");
      const parseErr = doc.querySelector("parsererror");
      if (parseErr) {
        throw new Error("Template XML parse error: " + parseErr.textContent.trim());
      }

      const priceMap = new Map();

      rows.forEach(r => {
        const nameNorm = normalizeModelNameFromCsv(r.name, r.storage);
        const storage = String(r.storage || "").trim().toUpperCase();
        const lockCarrier = normalizeCarrierLock(r.lock_status);
        if (!lockCarrier) return;

        const condRaw = String(r.condition || "").toLowerCase();
        let condTag;
        if (condRaw === "damaged") condTag = "broken";
        else if (condRaw === "flawless" || condRaw === "good" || condRaw === "fair") condTag = condRaw;
        else return;

        const newPrice = r.new_price;
        if (newPrice == null || !Number.isFinite(newPrice)) return;

        const key = nameNorm + "|" + storage + "|" + lockCarrier + "|" + condTag;
        priceMap.set(key, newPrice);
      });

      const models = doc.getElementsByTagName("model");
      for (let i = 0; i < models.length; i++) {
        const model = models[i];
        const nameEl = model.getElementsByTagName("name")[0];
        if (!nameEl) continue;
        const nameNorm = normalizeModelNameForFeed(nameEl.textContent);

        const pricesBlocks = model.getElementsByTagName("prices");
        for (let j = 0; j < pricesBlocks.length; j++) {
          const pricesBlock = pricesBlocks[j];
          const storageEl = pricesBlock.getElementsByTagName("storageSize")[0];
          if (!storageEl) continue;
          const storageVal = String(storageEl.textContent || "").trim().toUpperCase();

          const priceValueEl = pricesBlock.getElementsByTagName("priceValue")[0];
          if (!priceValueEl) continue;

          ["att", "verizon", "tmobile", "unlocked"].forEach(carrierTag => {
            const carrierEl = priceValueEl.getElementsByTagName(carrierTag)[0];
            if (!carrierEl) return;

            ["flawless", "good", "fair", "broken"].forEach(condTag => {
              const condEl = carrierEl.getElementsByTagName(condTag)[0];
              if (!condEl) return;

              const key = nameNorm + "|" + storageVal + "|" + carrierTag + "|" + condTag;
              if (priceMap.has(key)) {
                const val = priceMap.get(key);
                condEl.textContent = String(val);
              }
            });
          });
        }
      }

      const serializer = new XMLSerializer();
      let xmlOut = serializer.serializeToString(doc);

      if (!/^<\?xml/i.test(xmlOut.trim())) {
        xmlOut = '<?xml version="1.0" encoding="UTF-8"?>\n' + xmlOut;
      }

      // Pretty-print the entire XML so Pixels & everything else aren't on one mega-line
      xmlOut = prettyPrintXml(xmlOut);

      return xmlOut;
    }

    // ===================== UI WIRING =====================

    const csvFileInput = document.getElementById("csvFile");
    const xmlFileInput = document.getElementById("xmlFile");
    const templateXmlFileInput = document.getElementById("templateXmlFile");
    const csvTextArea = document.getElementById("csvInput");
    const btnProcessLocal = document.getElementById("btnProcessLocal");
    const priceIncreaseInput = document.getElementById("priceIncreaseAmount");
    const btnDownload = document.getElementById("btnDownload");
    const btnDownloadXml = document.getElementById("btnDownloadXml");
    const btnExportMatchingCsv = document.getElementById("btnExportMatchingCsv");
    const btnShowNewOnly = document.getElementById("btnShowNewOnly");
    const btnShowAll = document.getElementById("btnShowAll");

    let lastResultRows = [];
    let templateXmlText = "";

    csvFileInput.addEventListener("change", (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        csvTextArea.value = String(ev.target.result || "");
        setStatus("Loaded CSV file: " + file.name);
      };
      reader.onerror = () => {
        showError("Failed to read CSV file.");
      };
      reader.readAsText(file);
    });

    templateXmlFileInput.addEventListener("change", (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        templateXmlText = String(ev.target.result || "");
        setStatus("Loaded template XML: " + file.name);
        if (lastResultRows.length) {
          btnDownloadXml.disabled = false;
        }
      };
      reader.onerror = () => {
        showError("Failed to read template XML file.");
      };
      reader.readAsText(file);
    });

    btnProcessLocal.addEventListener("click", async () => {
      clearError();
      btnProcessLocal.disabled = true;
      btnDownload.disabled = true;
      btnDownloadXml.disabled = true;
      btnExportMatchingCsv.disabled = true;
      btnShowNewOnly.disabled = true;
      btnShowAll.style.display = "none";
      showingNewOnly = false;
      setStatus("Starting local processing...");
      lastResultRows = [];
      allResultRows = [];
      renderResults([]);

      try {
        const csvText = csvTextArea.value.trim();
        if (!csvText) {
          throw new Error("You must paste CSV or choose a CSV file first.");
        }

        const xmlFile = xmlFileInput.files && xmlFileInput.files[0];
        if (!xmlFile) {
          throw new Error("You must choose a SellCell XML file (feed export).");
        }

        setStatus("Reading SellCell XML file: " + xmlFile.name);
        const xmlText = await new Promise((resolve, reject) => {
          const r = new FileReader();
          r.onload = (ev) => resolve(String(ev.target.result || ""));
          r.onerror = () => reject(new Error("Failed to read SellCell XML file."));
          r.readAsText(xmlFile);
        });

        const feedIndex = buildFeedIndexFromXml(xmlText);
        window._currentFeedIndex = feedIndex;

        setStatus("Parsing CSV...");
        const rawRecords = csvToRecords(csvText);
        if (!rawRecords.length) {
          throw new Error("No data rows found in CSV. Make sure the header row includes: name,storage,lock_status,condition,price,amz");
        }
        console.log("[repricer] Parsed CSV rows:", rawRecords.length);

        const requiredCols = ["name", "storage", "lock_status", "condition", "price", "amz"];
        for (const col of requiredCols) {
          if (!(col in rawRecords[0])) {
            throw new Error("CSV is missing required column: " + col);
          }
        }

        setStatus("Detecting new storage variants...");
        const newVariants = detectAndAddMissingVariants(rawRecords, feedIndex);
        console.log("[repricer] New variants detected:", newVariants.length);

        const allRecords = [...rawRecords, ...newVariants];

        const priceIncreaseRaw = priceIncreaseInput.value;
        const priceIncreaseAmount = parseMoney(priceIncreaseRaw) || 1.00;

        setStatus("Applying repricer logic to " + allRecords.length + " rows (including " + newVariants.length + " new variants)...");

        const resultRows = allRecords.map((r, idx) => {
          const result = repriceRowFromFeed(r, feedIndex, priceIncreaseAmount);
          result._isNewVariant = r._isNewVariant || false;
          result._originalIndex = idx;
          return result;
        });

        lastResultRows = resultRows;
        allResultRows = resultRows;

        renderResults(resultRows);
        btnDownload.disabled = false;
        btnExportMatchingCsv.disabled = false;
        if (newVariants.length > 0) {
          btnShowNewOnly.disabled = false;
        }
        if (templateXmlText) {
          btnDownloadXml.disabled = false;
        }
        setStatus("Done – processed " + resultRows.length + " rows (" + newVariants.length + " new variants found).");
      } catch (err) {
        showError("Processing failed.", err);
      } finally {
        btnProcessLocal.disabled = false;
      }
    });

    btnDownload.addEventListener("click", () => {
      try {
        if (!lastResultRows.length) {
          showError("Nothing to download – process CSV & XML first.");
          return;
        }
        const csvOut = buildOutputCsv(lastResultRows);
        const blob = new Blob([csvOut], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "repricer-output.csv";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        setStatus("Downloaded repricer-output.csv");
      } catch (err) {
        showError("Failed to build output CSV.", err);
      }
    });

    btnExportMatchingCsv.addEventListener("click", () => {
      try {
        if (!allResultRows.length) {
          showError("Nothing to export – process CSV & XML first.");
          return;
        }
        const csvOut = buildMatchingFormatCsv(allResultRows);
        const blob = new Blob([csvOut], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const timestamp = new Date().toISOString().split('T')[0];
        a.download = `Devices Final-carriers-${timestamp}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        setStatus("Downloaded CSV in original format with new variants included");
      } catch (err) {
        showError("Failed to build matching format CSV.", err);
      }
    });

    btnShowNewOnly.addEventListener("click", () => {
      const newVariants = allResultRows.filter(row => row._isNewVariant);
      renderResults(newVariants);
      showingNewOnly = true;
      btnShowNewOnly.style.display = "none";
      btnShowAll.style.display = "inline-flex";
      setStatus(`Showing ${newVariants.length} new variants only`);
    });

    btnShowAll.addEventListener("click", () => {
      renderResults(allResultRows);
      showingNewOnly = false;
      btnShowAll.style.display = "none";
      btnShowNewOnly.style.display = "inline-flex";
      setStatus(`Showing all ${allResultRows.length} rows`);
    });

    btnDownloadXml.addEventListener("click", () => {
      try {
        if (!lastResultRows.length) {
          showError("Nothing to export – process CSV & XML first.");
          return;
        }
        if (!templateXmlText) {
          showError("You must upload a Template XML file (your device-prices XML) before exporting XML.");
          return;
        }

        const xmlOut = buildUpdatedXmlFromTemplate(templateXmlText, lastResultRows);
        const blob = new Blob([xmlOut], { type: "application/xml;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "device-prices-updated.xml";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        setStatus("Downloaded device-prices-updated.xml");
      } catch (err) {
        showError("Failed to build updated XML.", err);
      }
    });
  </script>

  <script type="module" src="/assets/js/global-auth.js" defer></script>
</body>
</html>
