const functions = require('firebase-functions');
const admin = require('firebase-admin');
const { defineSecret } = require('firebase-functions/params');
const cors = require('cors')({ origin: true });

// Define secrets
const stripeSecretKey = defineSecret('STRIPE_SECRET_KEY');
const stripeWebhookSecret = defineSecret('STRIPE_WEBHOOK_SECRET');

admin.initializeApp();
const db = admin.firestore();

// Ticket pricing tiers (server-side truth)
const TICKET_PRICES = {
  1: 12,
  5: 50,
  10: 80,
  20: 150,
  40: 300,
  55: 401,
};

function calculateCost(ticketCount) {
  let remaining = ticketCount;
  let total = 0;
  const sorted = Object.keys(TICKET_PRICES).map(k => parseInt(k, 10)).sort((a, b) => b - a);
  for (const count of sorted) {
    const price = TICKET_PRICES[count];
    const bundles = Math.floor(remaining / count);
    if (bundles > 0) {
      total += bundles * price;
      remaining %= count;
    }
  }
  return total;
}

/**
 * Callable function: createStripeCheckoutSession
 * Expects: { ticketCount: number, amount: number (dollars), firstName: string, phoneNumber: string }
 * Uses a secret for the Stripe API key.
 */
exports.createStripeCheckoutSession = functions.https.onCall(
  { secrets: [stripeSecretKey] },
  async (data, context) => {
    const stripe = require('stripe')(stripeSecretKey.value());

    // Defensive check for an empty payload
    if (!data || typeof data !== 'object' || Object.keys(data).length === 0) {
      console.error('[createStripeCheckoutSession] Received an empty or invalid payload.');
      throw new functions.https.HttpsError('invalid-argument', 'Request body is empty or invalid.');
    }

    console.log('[createStripeCheckoutSession] raw payload:', data);

    // Explicitly validate and cast inputs
    const ticketCount = Number(data.ticketCount);
    const amount = Number(data.amount);
    const firstName = typeof data.firstName === 'string' ? data.firstName.trim() : '';
    const phoneNumber = typeof data.phoneNumber === 'string' ? data.phoneNumber.trim() : '';

    console.log('[createStripeCheckoutSession] Parsed inputs:', {
      ticketCount: ticketCount,
      amount: amount,
      firstName: firstName,
      phoneNumber: phoneNumber,
      types: {
        ticketCount: typeof ticketCount,
        amount: typeof amount,
        firstName: typeof firstName,
        phoneNumber: typeof phoneNumber,
      },
      auth: {
        uid: context?.auth?.uid || null,
        token: !!context?.auth?.token,
      },
    });

    if (!Number.isInteger(ticketCount) || ticketCount <= 0) {
      console.error('[createStripeCheckoutSession] Invalid ticketCount:', data.ticketCount);
      throw new functions.https.HttpsError('invalid-argument', 'Invalid ticketCount');
    }
    if (!Number.isFinite(amount) || amount <= 0) {
      console.error('[createStripeCheckoutSession] Invalid amount:', data.amount);
      throw new functions.https.HttpsError('invalid-argument', 'Invalid amount');
    }
    if (!firstName) {
      console.error('[createStripeCheckoutSession] Missing firstName');
      throw new functions.https.HttpsError('invalid-argument', 'Missing firstName');
    }
    if (!phoneNumber) {
      console.error('[createStripeCheckoutSession] Missing phoneNumber');
      throw new functions.https.HttpsError('invalid-argument', 'Missing phoneNumber');
    }

    const calculatedAmount = calculateCost(ticketCount);
    if (Math.round(calculatedAmount * 100) !== Math.round(amount * 100)) {
      console.error('[createStripeCheckoutSession] Price mismatch:', {
        calculatedAmount,
        clientAmount: amount,
        ticketCount,
      });
      throw new functions.https.HttpsError('invalid-argument', 'Calculated amount does not match provided amount');
    }

    const amountInCents = Math.round(amount * 100);

    try {
      console.log('[createStripeCheckoutSession] Creating Stripe session with:', {
        ticketCount,
        amountInCents,
        firstName,
        phoneNumber,
      });

      const session = await stripe.checkout.sessions.create({
        payment_method_types: ['card'],
        line_items: [
          {
            price_data: {
              currency: 'usd',
              product_data: {
                name: 'YDE Senior Fund - Split the Pot Raffle',
                description: `Purchase of ${ticketCount} raffle ticket(s)`
              },
              unit_amount: amountInCents,
            },
            quantity: 1,
          }
        ],
        mode: 'payment',
        success_url: 'https://yderaffle.firebaseapp.com/success.html',
        cancel_url: 'https://yderaffle.firebaseapp.com/split-the-pot',
        metadata: {
          firstName,
          phoneNumber,
          ticketCount: String(ticketCount),
          amountPaid: String(amount)
        }
      });

      console.log('[createStripeCheckoutSession] Stripe session created:', session.id);

      await db.collection('pendingPayments').doc(session.id).set({
        sessionId: session.id,
        firstName,
        phoneNumber,
        ticketCount,
        amountPaid: amount,
        status: 'pending',
        createdAt: admin.firestore.FieldValue.serverTimestamp()
      });

      console.log('[createStripeCheckoutSession] pendingPayments doc created:', session.id);

      return { sessionId: session.id };
    } catch (err) {
      console.error('[createStripeCheckoutSession] Stripe session creation failed:', {
        message: err?.message,
        type: err?.type,
        code: err?.code,
        raw: err,
      });
      throw new functions.https.HttpsError('internal', 'Unable to create payment session');
    }
  }
);
exports.stripeWebhook = functions.https.onRequest(
  { secrets: [stripeSecretKey, stripeWebhookSecret] },
  async (request, response) => {
    const stripe = require('stripe')(stripeSecretKey.value());
    const sig = request.headers['stripe-signature'];
    let event;

    console.log('[stripeWebhook] Received webhook:', {
      hasSig: !!sig,
      headers: Object.keys(request.headers || {}),
      timestamp: new Date().toISOString(),
    });

    try {
      event = stripe.webhooks.constructEvent(request.rawBody, sig, stripeWebhookSecret.value());
    } catch (err) {
      console.error('[stripeWebhook] Signature verification failed:', err?.message);
      return response.status(400).send(`Webhook Error: ${err.message}`);
    }

    console.log('[stripeWebhook] Event type:', event.type);

    if (event.type === 'checkout.session.completed') {
      const session = event.data.object;
      const meta = session.metadata || {};
      const firstName = meta.firstName || '';
      const phoneNumber = meta.phoneNumber || '';
      const ticketCount = parseInt(meta.ticketCount, 10) || 0;
      const amountPaid = parseFloat(meta.amountPaid) || 0;

      console.log('[stripeWebhook] Parsed metadata:', {
        firstName, phoneNumber, ticketCount, amountPaid, sessionId: session.id,
      });

      if (!firstName || !phoneNumber || ticketCount <= 0 || amountPaid <= 0) {
        console.error('[stripeWebhook] Invalid session metadata:', meta);
        return response.status(400).end();
      }

      try {
        await db.collection('tickets').add({
          firstName,
          phoneNumber,
          ticketCount,
          amountPaid,
          paymentMethod: 'Credit Card',
          timestamp: admin.firestore.FieldValue.serverTimestamp()
        });

        console.log('[stripeWebhook] Ticket record added.');

        const countersRef = db.collection('counters').doc('raffle_totals');
        await db.runTransaction(async (t) => {
          const doc = await t.get(countersRef);
          const currentTickets = doc.exists ? (doc.data().totalTickets || 0) : 0;
          const currentAmount = doc.exists ? (doc.data().totalAmount || 0) : 0;

          t.set(countersRef, {
            totalTickets: currentTickets + ticketCount,
            totalAmount: currentAmount + amountPaid
          }, { merge: true });
        });

        console.log('[stripeWebhook] Counters updated.');

        try {
          await db.collection('pendingPayments').doc(session.id).delete();
          console.log('[stripeWebhook] pendingPayments cleaned up:', session.id);
        } catch (e) {
          console.warn('[stripeWebhook] Pending payment cleanup failed (non-fatal):', e?.message || e);
        }

        console.log('[stripeWebhook] Completed processing for session:', session.id);
      } catch (err) {
        console.error('[stripeWebhook] Error handling checkout.session.completed:', {
          message: err?.message,
          stack: err?.stack,
        });
        return response.status(500).end();
      }
    }

    response.status(200).end();
  }
);